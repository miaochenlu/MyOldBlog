# 数据链路层

# 1. 数据链路层的设计问题

数据链路层使用物理层提供的服务在通信信道上发送和接收比特。要实现的功能包括

* 向网络层提供一个定义良好的服务接口
* 处理传输错误
* 调节数据流，确保慢速的接受方不会被快速的发送方淹没

数据包被封装成帧，每个帧包含一个Header,一个Payload field,一个Trailer

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191012225542485.png" alt="image-20191012225542485" style="zoom:50%;" />

## 1.1 提供给网络层的服务

三种服务类型

* 无确认的无连接服务

> 特点
>
> * 事先不用建立物理连接，事后也不用释放逻辑连接
>
> * 源机器向目标机器发送独立的frame,目标机器不对这些frame进行确认
>
> 适合的场合
>
> * 实时通信[数据迟到比数据受损更难忍受]
>
> * 错误率比较低的场合[因为数据链路层可靠性不高，所以物理层reliable要求会高一点，适合有线网络

* 有确认的无连接服务

> 特点
>
> * 不用建立物理连接
> * 发送的每一帧都要单独确认，这样发送方可以知道一个帧是否已经正确到达目的地。如果一个帧在制定时间间隔内还没有到达，则发送方将再次发送该帧
> * 不能保证收到包的顺序和发送顺序一致
>
> 适用场合
>
> * 不可靠的信道：无线系统,WiFi

* 有确认的有连接服务

> 源机器和目标机器在传输任何数据之前要建立一个连接，连接发送每一帧都被编号，数据链路层确保发出的每个帧都会真正被接收方按顺序收到且只收到一次。相当于提供了一个可靠的比特流
>
> 适用场合
>
> * 长距离且不可靠的链路 



## 1.2 framing[成帧]

数据链路层要检测和纠正错误。

数据链路层通常的做法是将比特流拆分成多个离散的帧。

为每个帧计算一个称为校验和的短令牌，放在帧中一起传输。

帧到达目标机器时，重新计算校验和。如果新计算的校验和与传输过来的不同，说明产生了错误。



拆分方法

### 1.2.1 Byte count

Method: to use a field in the header to specify the number of characters in the frame.

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191008100755672.png" alt="image-20191008100755672" style="zoom:50%;" />

problem:

错了一个character count就会全错

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191012232424422.png" alt="image-20191012232424422" style="zoom:50%;" />



### 1.2.2  flag bytes with byte stuffing字节填充的标志字节法

考虑到出错之后到重新同步问题，用一些标志字节(flag byte)作为一个帧开始和结束

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191012233630323.png" alt="image-20191012233630323" style="zoom:50%;" />

如图所示的这种frame的结构

两个连续的flag标志了一帧的结束和下一帧的开始。

problem:

如果标志字节在数据中出现，会干扰到帧的分界



所以提出的解决方法是字节填充(byte stuffing)，发送方的数据链路层在数据中偶尔出现的每个标志字节前面插入一个特殊的转义字节(ESC),如果转移字符也出现在数据中，再用一个转义字符填充

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191012234408243.png" alt="image-20191012234408243" style="zoom:35%;" />

### 1.2.3 flag bit with bit stuffing

考虑到字节填充只能使用8bits的字节，这里bit填充可以使帧包含任意大小单元

flag bits 0111110

### 1.2.4 physical layer encoding violation



## 1.3 Error control



## 1.4 Flow control