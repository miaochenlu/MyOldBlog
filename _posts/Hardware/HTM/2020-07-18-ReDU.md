---
title: "ReDU"
tags: HTM hardware
key: page-ReDU



---

<!--more-->

# 

# Efﬁcient Hardware-assisted Logging with Asynchronous and Direct-Update for Persistent Memory



## Background

对undo, redo, undo+redo logging的评价：

* The undo approach experiences performance degradation due to **synchronous inplace data updates** since the log contains only the old values. 因为undo的数据必须在commit前forced write back, 所以必然在critical path中
* The undo+redo approach stores both old and new values, and does not require synchronous in-place data updates. However, the larger log size increases the amount of log writes. 
* The prior redo approach demands extra NVM read bandwidth for indirectly updating in-place data from the new values in logs.

基于上述思考，

For the efﬁciency of log writing, a critical aspect is to r<u>educe the amount of log writes</u> and <u>the number of logging requests</u> as much as possible.

<br>

NVM中的data更新的数据

可以有两种flush方式

* synchronous: The synchronous update places cache ﬂush operations on the critical path. The transaction must wait until the entire ﬂushing operations complete, resulting in a longer critical path in transaction execution.
* asynchronous: the asynchronous update allows transactions to ﬁnish without updating data inplace. The asynchronous update can make better use of the NVM bandwidth by parallelizing data updates of the committed transaction and log writes of the next transaction. However, the asynchronous update increases the complexity of cache modiﬁcations since caches need to track the write-sets of previous transactions.

可以有两种来源: 

* read directly from the cache hierarchy (direct updates)
* read from the logs stored in NVM (indirect updates)

<img src="../../../../assets/images/image-20200718214155662.png" alt="image-20200718214155662" style="zoom:50%;" />

direct updates是更加bandwidth efficient的，因为indirect updates需要多余的NVM reads来获取log中的内容

## 主要设计思想与贡献

对log writes和data updates这两个方面进行改进

* log coalescing and log packing

  <img src="../../../../assets/images/image-20200718213711964.png" alt="image-20200718213711964" style="zoom:50%;" />

* asynchronous and direct updates to NVM to reduce the critical path latency of transactions and to curtail unnecessary log reads from NVM.

<img src="../../../../assets/images/image-20200718214734214.png" alt="image-20200718214734214" style="zoom:50%;" />



<br>

ReDU的设计并不是Unbounded HTM, 它是L1 limited的，文章中提到:

> To record the write-set of the transaction, we add a transaction bit for each cacheline in the private L1 cache. If the cacheline with the transaction bit is evicted to lower level caches (e.g., L2 and L3), it is also ﬂushed to the DRAM cache. Note that this early update to the DRAM cache does not affect the correctness. When the transaction commits, the cache controller scans all cachelines in the private caches and ﬂushes them if the transaction bit is set

