# 1. Memory Organization 

典型计算机的存储器可分为

* 寄存器区域
* 较慢的直接编址的随机访问存储器 ( RAM )。 
  * RAM区域还可再分为代码区和数据区。 在绝大多数的语言中， 执行时不可能改变代码区， 且在概念上可将代码和数据区看作是**独立**的。另外由于代码区在执行之前是固定，所以在编译时所有代码的地址都是可计算的

<img src="../../assets/images/image-20200510185855839.png" alt="image-20200510185855839" style="zoom:50%;" />

### The general organization of runtime storage

<img src="../../assets/images/image-20200510190011538.png" alt="image-20200510190011538" style="zoom:50%;" />

* 生成的目标代码的大小在编译时刻就已经固定下来了，因此编译器可以将可执行目标代码防在一个静态确定的区域: 代码区。 这个区通常位于存储的低端。(上面是低)
* 程序的某些数据对象的大小在编译时刻知道，他们可以被放置在另一个称为静态区的区域中，该区域可以被静态确定。防止在这个区域的数据对象包括全局变量和编译器产生的数据，比如用于支持垃圾回收的信息。
  * 之所以要将尽可能多的对象进行静态分配，是因为这些对象的地址可以被编译到目标代码中。
* stack和heap防在剩余空间的相对两端，是动态的。stack用来存放**活动记录**， 这些活动记录在函数调用的过程中生成。

#### 静态和动态存储分配

静态表示编译时刻，动态表示运行时刻。

* 如果编译器只需要观察程序文本就可以做出存储分配决定，不需要观察程序在运行时做了什么，我们就认为这个存储分配决定是静态的。
* 如果只有在程序运行时才能做出决定，那么这个决定是动态的

编译器基本使用以下两种策略的某种组合来进行动态存储分配：

1. 栈式存储：一个过程的局部名字在栈中分配空间。这种栈支持过程的call/return policy
2. 堆存储：有些数据的生命周期要比创造它的某次过程调用更长，这些数据通常被分配在一个可复用存储的堆中。堆事虚拟内存的一个区域，他允许对象或其他数据元素在创建时获得存储空间，并在数据变得无效时释放该存储空间。为了支持堆堆管理，需要垃圾回收机制来检测出无用的数据元素



# 2. Stack Allocation of Space



有些语言使用procedures, functions, or methods作为 user-defined actions的单元。几乎所有针对这些语言的编译器都把他们的run-time memory按照一个stack进行管理。

* 当一个过程(函数，过程，方法，子例程的总称)被调用时，用于存放该过程的局部变量被压栈。

* 当这个过程结束时，空间被弹出栈

## 2.1 活动树

栈式分配的一个前提是过程调用在时间上是嵌套的。不是嵌套的话，就不行了。

如果过程p的一个活动调用了过程q, 那么q的该次活动必定在p的活动结束之前结束。有是那种常见的情况

1. q的该次活动正常结束，那么控制流从p中调用q的点之后继续。
2. q的该次活动直接或间接的中止，那么q和p同时结束
3. q的该次活动因为q不能处理的某个异常结束。
   * 过程p可能会处理这个异常，此时q的活动结束而p的活动继续执行，p不一定从调用q的点开始。
   * 如果p不能处理这个异常，那么p和q的活动一起结束

我们可以用一棵树来表示在整个程序运行期间的所有过程的活动，这棵树称为活动树(activation tree)。树中每个节点对应一个活动，根节点是main过程的活动。

在表示过程p的某个活动的节点上，他的子节点对应于被p的这次活动调用的各个过程的活动。我们按照调用顺序，自左向右显示他们。

注意：一个子节点必须在其有兄弟节点的活动开始之前结束

<br>

我们来看一个quicksort的例子

```cpp
int a[11];
//将9个整数读入a[1],...,a[9]
void readArray() {
  int i;
  ...
}

int partition(int m, int n) {
  
}

void quicksort(int m, int n) {
  int i;
  if(n > m) {
    i = partition(m, n);
    quicksort(m, i - 1);
    quicksort(i + 1, n);
  }
}
int main() {
  readArray();
  a[0] = -9999;
  a[10] = 9999;
  quicksort(1, 9);
}
```

main中有三个任务

* 调用readArray
* 设定上下限
* 调用quicksort

<img src="../../assets/images/image-20200510214852013.png" alt="image-20200510214852013" style="zoom:50%;" />

<img src="../../assets/images/image-20200510214927401.png" alt="image-20200510214927401" style="zoom:50%;" />

* 过程调用的序列和活动树的前序遍历对应
* 过程返回的序列和活动树的后序遍历对应



## 2.2 activation record

Procedure calls and returns通常由称为control stack的run-time  stack进行管理。

每个活跃的活动都有一个位于这个control stack的activation record。

活动树的根位于栈底，程序控制所在的活动记录位于栈顶。栈中全部活动记录的序列对应于在活动树中到大当前控制所在的活动节点的路径。



#### 活动记录中可能的内容有

<img src="../../assets/images/image-20200510190943555.png" alt="image-20200510190943555" style="zoom:50%;" />

* 临时值。比如点那个表达式求值过程中产生的中间结果无法存放在寄存器中时，就会生成这些临时值。
* 局部数据。对应于这个活动记录过程的局部变量
* 保存的机器状态。通常包含返回地址(PC的值)和寄存器的一些内容
* 访问链。当被调用过程需要另一个活动记录的数据时需要使用访问链进行定位。
* 控制链。指向**调用者**的活动记录

* 返回值。当被调用的函数有返回值时，要有一个用于存放这个返回值的空间。不是所有的调用过程都有返回值。即使有，我们也倾向于将返回值放到一个寄存器中提高效率
* 实在参数(actual parameter)。这些值通常尽可能放在寄存器中，而不是活动记录中。但是为了活动记录的通用性，我们仍然为他们预留了空间。



Example:

还是quicksort的例子。假设栈顶在下方



<img src="../../assets/images/image-20200510222429259.png" alt="image-20200510222429259" style="zoom:50%;" />



## 2.3 calling sequence

calling sequence时用来实现procedure call的代码段。他为一个活动记录在栈中分配空间，并在此记录的字段中填写信息

return sequence时一段类似的代码。他回复机器状态，使得调用过程能够在调用结束之后继续执行。

