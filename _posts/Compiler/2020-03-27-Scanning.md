---
layout: article
title: "Compilers--Scanning"
tag: Compiler
key: page-compilerScanning
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(34, 139, 87 , .4), rgba(139, 34, 139, .4))'
  background_image:
    src: https://miaochenlu.github.io/picture/image-20191208000900444.png.png


---

Scanning(Lexical Analysis)

<!--more-->

<style>
  .page__header .header__brand path {
    fill: rgba(255, 255, 255, .95);
  }
</style>
<br/>

<img src="../../../assets/images/image-20200304135523029.png" alt="image-20200304135523029" style="zoom:50%;" />

# 1. Scanning Process

scanner的任务是从源代码中读取字符并且将它们组织成逻辑单元，供后续parser处理。由scanner生成的逻辑单元称为token.

Tokens是通常被定义为枚举类型的逻辑实体, 比如：

```cpp
typedef enum 
{IF, THEN, ELSE, PLUS, MINUS, NUM, ID, ...}
TokenType;
```



### Token分类

* Identifier: 用户定义的串
* Integer
* Floating point
* String
* Comment
* Keyword: if else while break
* Symbol: + * { } ++ << 



token record

```cpp
typedef struct {
  TokenType tokenval;
  char* stringval;
  int numval;
} TokenRecord;
```

or possibly as a union

```cpp
typedef struct {
  TokenType tokenval;
  union {
    char* stringval;
    int numval;
  } attribute;
} TokenRecord;
```





# 2. Regular Expression

正则表达式表示了字符串的pattern. 一个正则表达式$r$被他所匹配的字符串完全定义。这个字符串的集合叫做language generated by the regular expression并且被写作$L(r)$。

## 2.1 正则表达式的定义

正则表达式是以下的一种

* 基本正则表达式由一个字符标$\Sigma$中的单子符$a$, 以及元字符$\varepsilon$(表示空串)或元字符$\phi$(表示空集)组成。
  * $L(a)=\{a\}$
  * $L(\varepsilon)=\{\varepsilon\}$
  * $L(\phi)=\{\}$

> 注意$\{\}$不包含任何串，$\{\varepsilon\}$包含一个没有任何字符的串

* $R\vert S$格式的表达式: 其中$R,S$都是正则表达式，以下也都是。$L(R\vert S)=L(R)\cup L(S)$
* $RS$格式的表达式: $L(RS)=L(R)L(S)$ (concatenation)
* $R^*$格式的表达式：$ R^*=\epsilon\vert R\vert RR\vert RRR\vert RRRR\cdots$
* $(R)$格式的表达式: $L((R))=L(R)$。括号不改变语言，只会调整运算的优先级

<br>

Precedence Rules and Parentheses

$$alternation<concatenation<repetition$$



#### Example

1. $\Sigma=\{a,b,c\}$

* the set of all strings over this alphabet that contain exactly one b

$$(a\vert c)^*b(a\vert c)^*$$

<br>

2. $\Sigma=\{a,b,c\}$

* the set of all strings that contain at most one b

$$(a\vert c)^*\vert (a\vert c)^*b(a\vert c)^*$$

$$(a\vert c)^*(b\vert \epsilon)(a\vert c)^*$$

<br>

3. $\Sigma=\{a,b\}$

* the set of strings consists of a single b surrounded by the same number of a's

$S={b, aba, aabaa,,, \cdots}={a^nba^n\vert n\not=0}$

{warning:.}

This set can not be described by a regular expression. Regular expression can't count !

<br>

## 2.2 正则表达式的扩展

* $R+:$  one or more string from $L(R)$: $R(R*)$

* $R?$:  optional $R$   &emsp;$ (R\vert \epsilon)$

* **.** : "."匹配任意字符
* 字符范围
  * \[abce]: one of the lsited characters: $(a\vert b\vert c\vert e)$
  * \[a-z]: one character from this range$(a\vert b\vert \cdots\vert z)$
  * \[ ^ab]:  anything but one of the listed chars 任何非a,b的字符
  * \[ ^a-z]: one character not from this range



<br>

## 2.3 Regular Expressions for programming language tokens

1. Numbers: 自然数，消暑，带有指数的数(由E表示)

$nat=[0-9]+$

$signedNat=(+\vert -)?nat$

$number=signedNat("."nat)?(E\;signedNet)?$

<br/>

2. Reserved Words and Identifiers

$reserved=if\vert while\vert do\vert\cdots$

$letter=[a-zA-z]$

$digit=[0-9]$

标识符必须由一个字母开头且只包含字母和数2字

$identifier=letter(letter\vert digit)*$

<br/>

3. Comment

<br/>

4. Ambiguity

Ambiguity: some  strings  can  be  matched  by  several  different regular expressions.

> * An identifier or a keyword--> choose keyword
> * A single token or a sequence of several tokens--->choose single token(最长字串原理)

但是在使用最长字串原理时会出现token delimiter的问题。究竟在遇到哪些符号时，我们认为两个字符串隔开了呢？

$whitespace= (newline\vert blank\vert tab\vert comment)^+$

lookahead: buffering of input characters, marking places for backtracing

<br>

# 3. Finite Automata

***Transition***:  record a change from one state to another upon a match of the character or characters by which they are labeled.

***start state***: the recognition process begins. drawing an unlabeled arrowed line  to it coming "from nowhere"

***accepting states***: represent the end of the recognition process. drawing a <u>double-line</u> border around the state in the diagram.

$$identifier=letter(letter\vert digit)^*$$

<img src="../../../assets/images/image-20200309181946457.png" alt="image-20200309181946457" style="zoom:50%;" />

## 3.1 Definite of Deterministic finite automation(DFA)

### A.Feature: 

DFA: automata where the next state is <font color=red>uniquely given by the current state and the current input character.

### B.Definition:

A DFA M consist of 

* an alphabet $\Sigma$
* a set of states S, 
* a transition function $T:S\times\Sigma\rightarrow S$, 
* a start state $s_0\in S$
* a set of acceepting states $F\sub S$

The language accepted by M, written L(M), is defined to be the set of string of characters $c_1c_2\cdots c_n$ with each $c_i\in \Sigma$ such that there exist states $s_1=t(s_0,c_1), s_2=t(s_1,c_2), s_n=T(s_{n-1},c_n)$ with $s_n$ is an element of F.



### C.Example:

<img src="../../../assets/images/image-20200309184300368.png" alt="image-20200309184300368" style="zoom:50%;" />

## 3.3 Lookahead, backtracking and nondeterministic automata

Typical actions

1. ***making a transition***: move the character from the input string to a string (the token string value or lexeme of the token)

2. ***reaching an accepting state*** : return the token just recognized, along with any associated attributes.

3. ***reaching an error state*** : either back up in the input (backtracking) or to generate an error token.



<img src="../../../assets/images/image-20200309185031171.png" alt="image-20200309185031171" style="zoom:35%;" /><img src="../../../assets/images/image-20200309185055605.png" alt="image-20200309185055605" style="zoom:35%;" />





### ***NFA***(nondeterministic finite automaton)

***$\varepsilon$ -transition***: transition that may occur without consulting the input string (and without consuming any characters) . It may be viewed as a "match" of the **empty string**.

> ***$\varepsilon$ -transition*** are useful in two ways:
>
> * Express a choice of alternatives in a way that **does not involve combining states**. Advantage: keeping the original automata intact and only adding a new start state to connect them.
>
> * Describe a match of the empty string explicitly.

<img src="../../../assets/images/image-20200309185031171.png" alt="image-20200309185031171" style="zoom:35%;" /><img src="../../../assets/images/image-20200309185528072.png" alt="image-20200309185528072" style="zoom:35%;" />



#### Difinition:

An NFA M consists of

* an alphabet $\Sigma$
* a set of states S
* a transition function $T:S\times(\Sigma \cup\{\varepsilon\})\rightarrow$
* a start state $s_0$ from S
* a set of accepting states A from S

The language accepted by M, written L(M), is defined to be the set of strings of characters $c_1c_2\cdots c_n$ with each $c_i$ from $\Sigma\cup\{\varepsilon\}$ such that there exist state $s_1$ in $T(s_0,c_1)$, $s_2$ in $T(s_1,c_2)$,$\cdots$, $s_n$ in $T(s_{n-1},c_n)$ with $s_n$ an element of A









## 3.4 From Regular Expression To DFAs

### A. Algorithm process

<img src="../../../assets/images/image-20200309202708452.png" alt="image-20200309202708452" style="zoom:50%;" />

### B. from a Regular Expression to an DFA

***Thompson’s construction***:

ε-transitions: to “<font color=red>glue together” the machine of each piece of a regular expression to form a machine that corresponds to the whole expression.

<img src="../../../assets/images/image-20200309202902409.png" alt="image-20200309202902409" style="zoom:50%;" />

### C. from an NFA to a DFA

The algorithm is called ***subset construction***:

1. the $\varepsilon$ -closure of a Set of states

the $\varepsilon$ -closure of a single state s is the set of states reachable by a series of ***zero or more $\varepsilon$-transitions.***

the $\varepsilon$ -closure of a set of states : the union of the $\varepsilon$ -closures of each individual state.



#### Example: regular a*

<img src="../../../assets/images/image-20200309203517606.png" alt="image-20200309203517606" style="zoom:50%;" />

$\bar{1}=\{1,2,4\},\bar{2}=\{2\}, \bar{3}=\{2,3,4\}, \bar{4}=\{4\}$

The $\varepsilon$ -closure of a set of states : the union of the $\varepsilon$ -closures of each individual state. 

$$\bar{S}=\underset{s\in S}\cup \bar{s}$$

$\overline{\{1,3\}}=\bar{1}\cup\bar{3}=\{1,2,4\}\cup\{2,3,4\}=\{1,2,3,4\}$

2. ***subset construction***

*  Compute the $\varepsilon$ -transitionclosure of the start state of M; this becomes the <font color=red>start state.

*  Given a set S of states and a character a in the alphabet, compute the set $S_a'$ = { t \vert  for some s in S there is a transition from s to t on a }. Then, compute , the $\varepsilon$ -closure of $S_a'$ .

* Continue with this process until no new states or transitions are created.

Mark as accepting those states constructed in this manner that contain an accepting state of M.

<img src="../../../assets/images/image-20200309204504030.png" alt="image-20200309204504030" style="zoom:50%;" />

| s       | S'      | $\overline{S'_a}$ | $\overline{S'_b}$ |
| ------- | ------- | ----------------- | ----------------- |
| 1       | 1,2,6   | 3,4,7,8           |                   |
| 3,4,7,8 | 3,4,7,8 |                   | 5,8               |
| 5,8     | 5,8     |                   |                   |

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200309205315637.png" alt="image-20200309205315637" style="zoom:50%;" />

### D. Minimizing the number of states in a DFA

Some result:

* Given any DFA, there is an equivalent DFA containing a minimum number of states, and that this minimum state DFA is <font color=red>unique (except for renaming of states).

*  It is also possible to directly obtain this minimum state DFA from any given DFA.

* the resulting DFA may be more complex than necessary. (deriving a DFA algorithmically from a regular expression )

#### Algorithm

* create two sets(做一个等价类的划分)

  * one consisting of all the accepting states
  * the other consisting of all the nonaccepting states

* Consider the transitions on each character a of the alphabet. 下面一堆总结起来就是：**目标状态集不一致，发生分离**

  * If all accepting states have transitions on <font color=brown>a to accepting states--->defines an <font color=brown>a-transition from the new accepting state (the set of all the old accepting states) to itself.
  * If all accepting states have transitions on <font color=brown>a to nonaccepting states--->defines an <font color=brown>a-transition from the new accepting state to the new nonaccepting state (the set of all the old nonaccepting stales)

  * If there are two accepting states s and t that have transitions on <font color=brown>a that land in different sets, no <font color=brown>a-transition can be defined for this grouping of the states. We say that <font color=brown>a  distinguishes the states s and t. 
  * If there are two accepting states s and t such that s has an <font color=brown>a -transition to another accepting state, while t has no <font color=brown>a -transition at all (i.e., an error transition) , then font color=brown>a distinguishes s and t.
  * If any further sets are split, we must return and repeat the process from the beginning.

This process continues until

1. all sets contain only one element (in which case, we have shown the original DFA to be minimal)

2. until no further splitting of sets occurs.









