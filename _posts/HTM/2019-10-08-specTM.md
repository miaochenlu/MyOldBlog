---
title: "SpecTM"
tags: HTM
key: page-spectm

---





- speculation based on hardware dependency tracking and cacheable undo log without obvious degration on speculation failure.
- We leverage cascaded speculative transaction to enforce efficient ACI out of ACID by employing lazy concur- rency control which uses dependency tracking to allow maximum interleaving.
- We propose speculative commit to provide fast Durability out of ACID by al



# 2. Backgound

## A. Concurrency Control

### i. Pessimistic concurrency control

用互斥锁，在冲突发生之前就有了计划，提前锁住，冲突就不会发生

### ii. Optimistic concurrency control

冲突发生时才控制，导致abort



### iii. Lazy Concurrency Control

Strict isolation is not necessary for transactions demanding the same data as long as proper dependency is maintained during their execution.



## B. Durability

Essence:

> In a persistent memory system, transactions are expected to persist on memory the moment they are logically committed, which summarizes the essence of transaction durability.

### i. Atomic Durability

要做全做，要么不做。用write-ahead logging。

要先写log,后写data



### ii. Strict and Relaxed Durability

# 3 SpecTM design

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191008153739808.png" alt="image-20191008153739808" style="zoom:50%;" />



### A. Decouple Isolation by Speculative Execution

HTM使用optimistic concurrency control来提供strong isolation.

但是，这样会导致很大的开销。因为任何transaction必须等待有overlapping access dataset的transaction.

specTM使用了speculative execution来降低overhead。这是execute transaction with temporary inconsistent access to shared data. 

为了达到这个目标，需要More sophisticated protocol is needed to protect consistency at transaction commit under relaxed isolation constraint.



#### i. Concurrency control protocol

OOC如何检测冲突

>  Optimistic Concurrency Control conducts isolation by detect inter-thread conflict where a thread tries to access a cache line which has been modified by others and still in speculative state

我们的方法是允许tranaction去read intermediate data from concurrent transaction in speculative mode



<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191008154526299.png" alt="image-20191008154526299" style="zoom:50%;" />





#### ii. Dependency Tracking

track dynamic dependency



### Decouple Durability by Speculative commit

allow persistent memory to keep stale but consistent view of data.

In this way, persist barrier can be reduced and delayed

#### i. why undo logging

可以减少persist barriers

recovery时， undo log可以恢复到旧值，redo log是用来恢复到新值的。

Undo log可以是不完整的，只要它们覆盖了溢出的新数据，而redo log必须作为一个组保存，避免broken recovery。

如图1所示，undo log distributes log- data barriers along the transaction

redo log requires a complete flush of all log entries



<img src="/Users/jones/Desktop/屏幕快照 2019-10-08 下午4.06.27.png" alt="屏幕快照 2019-10-08 下午4.06.27" style="zoom:50%;" />



#### ii. Order Constraint in Relaxed Durability

Figure 4, a complete life cycle from speculative commit to durable apply contains two order constraints: log between data and data between log retirement.

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191008161015684.png" alt="image-20191008161015684" style="zoom:50%;" />

After applying, all speculative modifications are made persistent in memory, and thus release the log.这个时刻，transaction是真正在persistent view里面提交了



#### iii. Cacheable Logging and Speculative Commit

Basic idea is to emulate log entry w.r.t. data entry such that they are mapped to the same cacheline and stay ordered if no disrupting access request is made. 

Requirement:

> a. log is created before data
>
> b. data and log can't coexist in any cache level

假设是direct-mapping cache，就是吧相同后缀内存地址的都映射到相同的cache line。我们让data和log共享相同的地址后缀，就可以实现b。

另一个问题是read operation on data address will lead to a total eviction of all data sharing the same postfix, which leads to a point where log has to be flushed anyway.

为了解决这个问题，我们引入data read redirect which lead transactional read to the nearest data sharing the same postfix



#### iv. Circular Retirement and checkpointing

One of the biggest challenges to cacheable logging by address emulation is <u>cost of emulation space</u>.

* unlimited use of contiguous memory space is unacceptable
* the total order of transaction commit must hold for persistent layer

解决这两个问题的方法是

apply transaction and clear it’s log in time and order



我们提出的方法是

> checkpoint operation as open interface to both hardware and software system, and a corresponding hardware routine that protect transactions from overflow or out-of-order at persistent level.



The operating of checkpoint must ensure a persistent order of commit. We propose a circular log area that realize this order. First, each transaction must hold a unique ID at that time, this ID is the identifier to locate its log area in a circular array. Then checkpoint on N transaction is converted to checkpointing of all transactions that is older than ID n. By adding global transaction ID register to controller, those routines can be covered in instruction stream.

# 4. Implementation

## A. Software Support

* defining persistent memory transactions,

* allocating and truncating the circular log in NVRAM

- reserving a special character as the log header indicator.

### i. transaction interface

```cpp
int main() {
  //complete mode
  txn_id = txn_begin();
  txn_read(txn_id, &A, &B);
  txn_write(txn_id, &A, B);
  txn_commit(txn_id);
  txn_checkpoint(txn_id);
  
  //fallback mode
  txn_begin;
  /*operations*/
  txn_end;
}
```

complete mode

> transaction is definded by ***txn_id***,这个是在硬件层动态分配的。
>
> 利用事务ID,用户可以在其他代码中间分布事务操作，不用担心底层的顺序。此外，为了最好的性能，在完整模式下，commit与persist解耦。用户可以调用txn_checkpoint来强制同步持久性进程。

Fallback mode

> 由txn_begin; txn_end;紧凑包装起来
>
> Transaction executed in this manner is guaranteed to behave in traditional ACID way.

### ii. Optional Compiler Support



## B. Non-Volatile Area Extension

如图二所示

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191008153739808.png" alt="image-20191008153739808" style="zoom:50%;" />

两个persitent components加到了体系结构里面:preserved log area and mera-log area.

### i. Preserved Circular Log Array

In SpecTM, the write order between data and log is achieved through emulated log address.也就是log和data有同样的地址后缀，这样可以被映射到同一个cache line

persistent memory must provide a contiguous area with the size of LLC to emulate all possible transaction data.

We refer to this area as Transaction Log Domain.



### ii. Memory Controller Extension

a) Add Transaction and Modify its Write Set

b) Query Write Set by Transaction ID.

To improve the performance of checkpointing, certain operation extensions are needed in memory controller. 

On data output from cache to memory, memory controller will check transaction manifest and invalidate any existing entry related to the output line. 

In this way, checkpoint size can be reduced to minimum and spare the redundant work of clflush on empty cache line.



## C. Volatile Area Extension

### i. Special Registers

从tx_begin()得到的txn_id translates成一个8bit的unsigned int(这8个bits事物理事务ID) ,被存储在处理器的一个特殊的寄存器中。

因为事务ID组写的是相同的事务，所以我们可以简单的选择一个未使用的物理事务ID来表示一个新接受到的txid。8bit的长度一次可以容纳256个独一无二的活跃的persistent memory transaction。一个物理事务ID可以在事务提交之后重用。



### ii. Cache Modification

在设计级别的一个关键假设是，可以通过cache冲突来保持写顺序，这在直接映射的cache层次中是一个不变的事实。但是，现代处理器体系结构很少采用这种经常发生冲突的相对简单的模式。为了将这一关键性质扩展到set-associative cache，我们对传统cache进行了改进。

如图6所示，只要简单添加一个事务bit,就可以修改事务数据上的cache read行为。为了正式specify新的行为，我们遍历一条数据线的生命周期：

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20190922133509857.png" alt="image-20190922133509857" style="zoom:50%;" />

- 第一次读取： 在非事务模式下读取，现在数据被保存在local cache中，设置事务bit
- 接下来的读取：在事务模式在读取，获取与请求具有相同后缀的最近的数据值
- 写：控制器将选择具有相同标记后缀的slot，并且在新数据写之前触发early write-back，这种写回事事务模式的特殊行为