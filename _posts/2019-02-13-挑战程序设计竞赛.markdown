---

layout: post

title: "挑战程序设计竞赛"

date: 2019-02-14 12:21:05 +0800

categories: jekyll update

---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


## 第一章
<img src="http://miaochenlu.github.io/picture/20190214triangle.png">
* 第一种方法  
三根棍子能组成三角形的充要条件是 **最长棍子的长度<其余两根棍子的长度之和**  
用三重循环判断三根棍子是否符合上述条件
复杂度:$$O(n^3)$$
```c
int n;
int a[MAX_N];
void solve()
{
    int ans = 0;
    for(int i = 0; i < n; i++) {
        for(int j = i + 1; j < n; j++) {
            for(int k = j + 1; k < n; k++) {
                int len = a[i] + a[j] + a[k];           //周长
                int ma = max(a[i], max(a[j], a[k]));    //最长边
                int rest = len - ma;                    //另外两边之和
                if(rest > ma) ans = max(len, ans);      //判断最大周长
            }
        }
    }
    printf("%d\n", ans);
}
```
* 第二种方法  
对长度进行排序，依次判断连续三个数是否能形成三角形。  
如果不能，则说明最长的那根太长了，需舍弃；再找前一根   
如果能，就找到了
```c
void solve()
{
    int ans = 0;
    sort(a, a + n);                           
    for(int i = n - 3; i >= 0; i--) {
        int len = a[i] + a[i + 1] + a[i + 2];
        if(a[i] + a[i + 1] > a[i + 2])
            ans = max(ans, len);
    }
    printf("%d\n", ans);
}
```

<img src="http://miaochenlu.github.io/picture/20190214ants.png">
解题思路:  
穷举肯定复杂度爆炸
<img src="http://miaochenlu.github.io/picture/20190214antsol.png">
考虑到这个我们只要对每一只蚂蚁进行考虑就可以了
```c
int L, n;
int X[MAX_N];

void solve()
{
    int minT = 0;
    for(int i = 0; i < n; i++)
        minT = max(minT, min(X[i], L - X[i]));
    
    int maxT = 0; 
    for(int i = 0; i < n; i++) 
        maxT = max(maxT, max(X[i], L - X[i]));
    
    printf("%d %d\n", minT, maxT);
}
```
<img src="http://miaochenlu.github.io/picture/20190214drawlots.png">
* 暴力搜  
```c
void solve()
{
    bool f = false;
    for(int a = 0; a < n; a++) 
        for(int b = 0; b < n; b++) 
            for(int c = 0; c < n; c++) 
                for(int d = 0; d < n; d++)
                    if(k[a] + k[b] + k[c] + k[d] == m)
                        f = true;
    
    if(f) puts("Yes");
    else puts("No");
}
```
* 二分搜索与$$O(n^3logn)$$的算法  
记所要查找的值 $$m-k_a-k_b-k_c为x$$ ，预先把数组k排好序，然后看k中央的数字
    * 如果它比x小，x只可能在后半段
    * 如果它比x大，x只可能在前半段  
复杂度:
    * 排序$$O(nlogn)$$        
    * 循环$$O(n^3logn)$$
    
```c
int n, m, k[MAX_N];

bool binary_search(int x) 
{
    //x的存在范围为k[l]---k[r-1]
    int l = 0, r = n;

    //反复操作直到存在范围为空
    while(r - l >= 1) {
        int i = (r + l) / 2;
        if(k[i] == x) return true;//找到x
        else if(k[i] < x) l = i + 1;
        else r = i;
    }
    //没找到x
    return false;
}
void solve()
{
    std::sort(k, k + n);
    bool f = false;
    for(int a = 0; a < n; a++) {
        for(int b = 0; b < n; b++) {
            for(int c = 0; c < n; c++) {
                if(binary_search(m - k[a] - k[b] - k[c]))
                    f = true;
            }
        }
    }
    if(f) puts("Yes");
    else puts("No");
}
```
* $$O(n^2logn)$$的算法
检查是否有$$c和d使得k_c+k_d=m-k_a-k_b$$，可以预先枚举出$$k_c+k_d$$所得的$$n^2$$个数字排好序，再用二分搜索    
复杂度：
    * 排序$$O(n^2logn)$$        
    * 循环$$O(n^2logn)$$


```c
int n, m, k[MAX_N];
int kk[MAX_N * MAX_N];
bool binary_search(int x) 
{
    //x的存在范围为k[l]---k[r-1]
    int l = 0, r = n * n;

    //反复操作直到存在范围为空
    while(r - l >= 1) {
        int i = (r + l) / 2;
        if(kk[i] == x) return true;//找到x
        else if(kk[i] < x) l = i + 1;
        else r = i;
    }
    //没找到x
    return false;
}

void solve()
{
    for(int c = 0; c < n; c++)
        for(int d = 0; d < n; d++) 
            kk[c * n + d] = k[c] + k[d];

    std::sort(kk, kk + n * n);
    bool f = false;
    for(int a = 0; a < n; a++) {
        for(int b = 0; b < n; b++) {
                if(binary_search(m - k[a] - k[b]))
                    f = true;
        }
    }
    if(f) puts("Yes");
    else puts("No");
}
```
## 第二章
### 深度优先搜索
<img src="http://miaochenlu.github.io/picture/20190215partialsum.png">
<img src="http://miaochenlu.github.io/picture/20190215dfstrans.png">
```c
int n, k;
int a[MAX_N];
//已经从前i项得到了和sum,然后对于i项之后的进行分支
bool dfs(int i, int sum) 
{
    //如果前n项都计算过了，则返回sum是否与k相等
    if(i == n) return sum == k;
    
    //不加上a[i]的情况
    if(dfs(i + 1, sum)) return true;
    
    //加上a[i]的情况
    if(dfs(i + 1, sum + a[i])) return true;
    return false;//这句好像不必要
}

void solve()
{
    if(dfs(0, 0)) printf("Yes\n");
    else printf("No\n");
}
```

### 广度优先搜索
<img src = "http://miaochenlu.github.io/picture/20190218lakecounting.png">
解题思路:从任意W开始，不停地把邻接的部分用.代替。1次dfs后与初始的W连接的所有W都被替换成了.。直到图中不存在W为止，总共的dfs次数就是答案，8个方向对应了8种状态转移。
```c
#include <cstdio>
const int MAX_N = 50;
const int MAX_M = 50;
int N, M;
char field[MAX_N][MAX_M + 1];

void dfs(int x, int y) {
    //将现在所在位置替换成.
    field[x][y] = '.';
    //循环遍历移动的8个方向
    for(int dx = -1; dx <= 1; dx++) {
        for(int dy = -1; dy <= 1; dy++) {
            //向x方向移动dx,向y方向移动dy,移动的结果为(nx, ny)
            int nx = x + dx, ny = y + dy;
            //判断(nx, ny)是否在园子里以及是否有积水
            if(0 <= nx && nx < N && 0 <= ny && ny < M && field[nx][ny] == 'W')
                dfs(nx, ny);
        }
    }
}
void solve()
{
    int res = 0;
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < M; j++) {
            if(field[i][j] == 'W') {
                dfs(i, j);
                res++;
            }
        }
    }
    printf("%d\n", res);
}

int main(int argc, char const *argv[])
{
    scanf("%d %d", &N, &M);
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < M; j++) {
            scanf("%c", &field[i][j]);
        }
        getchar();//注意这个地方不写会导致输入错误
    }
    solve();
    return 0;
}
```
宽度优先搜索与深度优先搜索一样，都会生成所有能够遍历到的状态，因此需要对所有状态进行处理时使用宽度优先搜索也是可以的。但是递归函数可以简短地编写，而且状态的管理也更加简单，所以大多数情况下还是深度优先搜索实现。反之，在求取最短路时深度优先搜索需要反复经历同样的状态，所以此时还是使用宽度优先搜索为好。  
宽度优先搜索会把状态逐个加入队列，因此通常需要与状态数成正比的内存空间。反之，深度优先搜索是与最大的递归深度成正比的。一般与状态数相比，递归的深度不会太大，所以可以认为深度优先搜索更加节省内存。  
## 一直往前，贪心法
<img src = "http://miaochenlu.github.io/picture/20190224coins.png">
```c
//硬币的面值
const int V[6] = {1, 5, 10, 50, 100, 500};
int C[6];
int A;
//输入
void solve() {
    int ans = 0;
    for(int i = 5; i >= 0; i--) {
        int t = min(A / V[i], C[i]);//使用硬币i的枚数
        A -= t * V[i];
        ans += t;
    }
    cout << ans << endl;
}
```
```c
const int MAX_N = 100000;
//输入
int N, S[MAX_N], T[MAX_N];
pair<int, int> itv[MAX_N];
void solve() {
    for(int i = 0; i < N; i++) {
        itv[i].first = T[i];
        itv[i].second = S[i];
    }
    sort(itv, itv + N);
    int ans = 0; 
    int t = 0;
    for(int i = 0; i < N; i++) {
        if(t < itv[i].second) {
            ans++;
            t = itv[i].first;
        }
    }
    cout << ans;
}
```
[jekyll-docs]: https://jekyllrb.com/docs/home

[jekyll-gh]: https://github.com/jekyll/jekyll

[jekyll-talk]: https://talk.jekyllrb.com/
