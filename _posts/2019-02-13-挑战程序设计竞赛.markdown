---

layout: post

title: "挑战程序设计竞赛"

date: 2019-02-14 12:21:05 +0800

categories: jekyll update

---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


## 第一章
<img src="http://miaochenlu.github.io/picture/20190214triangle.png">
* 第一种方法  
三根棍子能组成三角形的充要条件是 **最长棍子的长度<其余两根棍子的长度之和**  
用三重循环判断三根棍子是否符合上述条件
复杂度:$$O(n^3)$$
```c
int n;
int a[MAX_N];
void solve()
{
    int ans = 0;
    for(int i = 0; i < n; i++) {
        for(int j = i + 1; j < n; j++) {
            for(int k = j + 1; k < n; k++) {
                int len = a[i] + a[j] + a[k];           //周长
                int ma = max(a[i], max(a[j], a[k]));    //最长边
                int rest = len - ma;                    //另外两边之和
                if(rest > ma) ans = max(len, ans);      //判断最大周长
            }
        }
    }
    printf("%d\n", ans);
}
```
* 第二种方法  
对长度进行排序，依次判断连续三个数是否能形成三角形。  
如果不能，则说明最长的那根太长了，需舍弃；再找前一根   
如果能，就找到了
```c
void solve()
{
    int ans = 0;
    sort(a, a + n);                           
    for(int i = n - 3; i >= 0; i--) {
        int len = a[i] + a[i + 1] + a[i + 2];
        if(a[i] + a[i + 1] > a[i + 2])
            ans = max(ans, len);
    }
    printf("%d\n", ans);
}
```

<img src="http://miaochenlu.github.io/picture/20190214ants.png">
解题思路:  
穷举肯定复杂度爆炸
<img src="http://miaochenlu.github.io/picture/20190214antsol.png">
考虑到这个我们只要对每一只蚂蚁进行考虑就可以了
```c
int L, n;
int X[MAX_N];

void solve()
{
    int minT = 0;
    for(int i = 0; i < n; i++)
        minT = max(minT, min(X[i], L - X[i]));
    
    int maxT = 0; 
    for(int i = 0; i < n; i++) 
        maxT = max(maxT, max(X[i], L - X[i]));
    
    printf("%d %d\n", minT, maxT);
}
```
<img src="http://miaochenlu.github.io/picture/20190214drawlots.png">
* 暴力搜  
```c
void solve()
{
    bool f = false;
    for(int a = 0; a < n; a++) 
        for(int b = 0; b < n; b++) 
            for(int c = 0; c < n; c++) 
                for(int d = 0; d < n; d++)
                    if(k[a] + k[b] + k[c] + k[d] == m)
                        f = true;
    
    if(f) puts("Yes");
    else puts("No");
}
```
* 二分搜索与$$O(n^3logn)$$的算法  
记所要查找的值 $$m-k_a-k_b-k_c为x$$ ，预先把数组k排好序，然后看k中央的数字
    * 如果它比x小，x只可能在后半段
    * 如果它比x大，x只可能在前半段  
复杂度:
    * 排序$$O(nlogn)$$        
    * 循环$$O(n^3logn)$$
```c
int n, m, k[MAX_N];

bool binary_search(int x) 
{
    //x的存在范围为k[l]---k[r-1]
    int l = 0, r = n;

    //反复操作直到存在范围为空
    while(r - l >= 1) {
        int i = (r + l) / 2;
        if(k[i] == x) return true;//找到x
        else if(k[i] < x) l = i + 1;
        else r = i;
    }
    //没找到x
    return false;
}
void solve()
{
    std::sort(k, k + n);
    bool f = false;
    for(int a = 0; a < n; a++) {
        for(int b = 0; b < n; b++) {
            for(int c = 0; c < n; c++) {
                if(binary_search(m - k[a] - k[b] - k[c]))
                    f = true;
            }
        }
    }
    if(f) puts("Yes");
    else puts("No");
}
```
* $$O(n^2logn)$$的算法
检查是否有$$c和d使得k_c+k_d=m-k_a-k_b$$，可以预先枚举出$$k_c+k_d$$所得的$$n^2$$个数字排好序，再用二分搜索  
复杂度：
    * 排序$$O(n^2logn)$$        
    * 循环$$O(n^2logn)$$
```cpp
int n, m, k[MAX_N];
int kk[MAX_N * MAX_N];
bool binary_search(int x) 
{
    //x的存在范围为k[l]---k[r-1]
    int l = 0, r = n * n;

    //反复操作直到存在范围为空
    while(r - l >= 1) {
        int i = (r + l) / 2;
        if(kk[i] == x) return true;//找到x
        else if(kk[i] < x) l = i + 1;
        else r = i;
    }
    //没找到x
    return false;
}

void solve()
{
    for(int c = 0; c < n; c++)
        for(int d = 0; d < n; d++) 
            kk[c * n + d] = k[c] + k[d];

    std::sort(kk, kk + n * n);
    bool f = false;
    for(int a = 0; a < n; a++) {
        for(int b = 0; b < n; b++) {
                if(binary_search(m - k[a] - k[b]))
                    f = true;
        }
    }
    if(f) puts("Yes");
    else puts("No");
}
```
[jekyll-docs]: https://jekyllrb.com/docs/home

[jekyll-gh]: https://github.com/jekyll/jekyll

[jekyll-talk]: https://talk.jekyllrb.com/
