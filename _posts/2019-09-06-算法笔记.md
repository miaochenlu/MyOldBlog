---
layout: post

title: "算法笔记"

date: 2019-09-06 15:43:05 +0800

categories: jekyll update

---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


# 算法初步

## 1 sort

### 1.1 选择排序

<img src="/Users/jones/Desktop/miaochenlu.github.io/picture/image-20190821164223597.png" width=500>

```cpp
void selectSort() {
  for(int i = 0; i < n; i++) {
    int minPos = i;
    for(int j = i; j < n; j++) {
      if(A[j] < A[minPos])
        minPos = j;
    }
    int tmp = A[minPos];
    A[minPos]= A[i];
    A[i] = tmp;
  }
}
```

### 1.2 插入排序

![image-20190821165228172](/Users/jones/Desktop/miaochenlu.github.io/picture/image-20190821165228172.png)

```cpp
void insertionSort() {
  for(int i = 1;  i < n; i++) {
    int key = A[i];
    int j = i;
    while(j > 0 && A[j] > key) {
      A[j] = A[j - 1];
      j--;
    }
    A[j] = key;
  }
}
```

### 1.3 结构体排序

*  结构体如下所示

```cpp
struct Student {
  char name[10];
  char id[10];
  int score;
  int r;
}stu[100010];
```

* 如何编写cmp函数

  该cmp函数的意思是

  如果两个学生的分数不相同，那么分数高的排在前面

  否则，将姓名字典序小的排在前面

```cpp
bool cmp(Student a, Student b) {
  if(a.score != b.score)
    return a.score > b.score;
  else return strcmp(a.name, b.name) < 0;
}
```

* 排名的实现

排序之后给出个体的排名

一般策略：

分数不同排名不同

分数相同排名相同但都占用一个排位

```cpp
stu[0].r = 1;	//第0个元素排名为1
//后续元素，如果与前一元素相等，则排名也与前一元素相同
//如果与前一元素不相同，排名就是下标+1
for(int i = 1; i < n; i++) {
  if(stu[i].score == stu[i - 1].score) {
    stu[i].r = stu[i - 1].r
  } else {
    stu[i].r = i + 1;
  }
}
```



# 2 散列

## 2.1 散列引出

一个问题来引出散列的思想：

有N个正整数，我们给出M个正整数，看这M个数是否在那N个数中出现过 $N,M\leq 10^5$

如：N=5,M=3,N个正整数为{8,3,7,6,2},想要查询的M个数为{7,4,2}，只有4没有出现过

$nbsp;

一个算法思想：很暴力

对每一个要查询的数x,遍历N个数，看看是否出现过，可以看到复杂度 $O(MN)$,这个复杂度有时候是难以承受的

Hash思想：

$emsp;用空间换时间

$emsp;我们设定一个bool型数组`hashTable[100010]`,`hashTable[x]=true`表示正整数x在N个数中出现过，false同理

$emsp;首先预设hashTable[x]=false,即所有数都没有出现过，接下来读入N个数进行预处理，hashTable[x]=true。接下来对M个数，用hashTable[x]判断这个数有没有出现过

$emsp;

​	复杂度降低为 $O(N+M)$

```cpp
#include<cstdio>
const int maxn = 10010;

bool hashTable[maxn] = {false};

int main() {
  int n, m, x;
  for(int i = 0; i < n; i++) {
    scanf("%d", &x)
    hashTable[x] = true;
  }
  for(int i = 0; i < m; i++) {
    scanf("%d", &x);
    if(hashTable[x] == true) {
      printf("Yes\n");
    } else {
      printf("No\n");
    }
  }
}
```

$nbsp;

变体：

如果题目要求M个要查询的数在N个数中的出现次数，那么我们把hashTable变成int数组，每次hashTable[x]++

$nbsp;

```cpp
#include<cstdio>
const int maxn = 10010;

int hashTable[maxn] = {false};

int main() {
  int n, m, x;
  for(int i = 0; i < n; i++) {
    scanf("%d", &x)
    hashTable[x]++;
  }
  for(int i = 0; i < m; i++) {
    scanf("%d", &x);
   	printf("%d\n", hashTable[x])
  }
}
```

![image-20190823202301873](/Users/jones/Library/Application Support/typora-user-images/image-20190823202301873.png)

## 2.2字符串与hash初步

![image-20190823203317232](/Users/jones/Library/Application Support/typora-user-images/image-20190823203317232.png)

补充一下，哈希函数H(P)不能保证 $H(P_1)\neq H(P_2)$

比如 $0\leq x,y\leq 3$, $(x,y)=(0,3),(x,y)=(1,0)$有着相同的哈希值

![image-20190823204604429](/Users/jones/Library/Application Support/typora-user-images/image-20190823204604429.png)





## 3 递归

#### 3.1 全排列

```cpp
#include <cstdio>
const int maxn = 11;
int n, P[maxn], hashTable[maxn] = {false};

vodi generateP(int index) {
  if(index == n + 1) {
    
  }
}
```

