```mua
make "sqrt [
	[x]
	[output sqrt_it :x 1]
]
make "sqrt [
	[x guess]
	[
		if closeenough :x square :guess
			[output guess]
			[output sqrt :x improve :guess :x]
	]
]

make "improve [
	[guess x]
	[
		output div add :guess div :x :guess 2
	]
]

make "closeenough [
	[x y]
	[
		output lt abs sub :x :y 0.001
	]
]
make "square [
	[guess]
	[output mul :guess :guess]
]
```

## 关于递归和尾递归

**递归**：

一个过程是递归 (*recursive*) 的， 也就是: 在过程的定义中（直接或间接地）引用了该过程本身。

**尾递归**是递归调用的一种实现：

尾递归是递归调用的一种实现，如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归 (*tail-recursive*) 的。

尾调用的重要性在于它可以**不在调用栈上面添加一个新的堆栈帧——而是更新它**，如同迭代一般。

在 SICP (Structure and Interpretation of Computer Programs) 中，尾递归形式的实现称为**迭代**(*iterative* ) 过程。

<a href="https://zhuanlan.zhihu.com/p/36587160">excellent article</a>

### Linear Recursion and Iteration

#### factorial

```mua
//递归版本
make "factorial [
	[n]
	[
		if lt :n 2
		[output 1]
		[output mul factorial (:n - 1) :n]
	]
]
```

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200114224741658.png" alt="image-20200114224741658" style="zoom:50%;" />



```mua
//iterative???
make "factorial_iter[
	[product counter n]
	[
    if gt :counter :n
    [output :product]
    [output factorial_iter (:product * :counter) (:counter+1) :n]
	]
]
```

为啥我觉得这个是尾递归



### Tree Recursion

```mua
make "fib [
	[n]
	[
		if lt :n 2
      [output 1]
      [output (fib (:n - 1) + fib (:n - 2))]
  ]
]
```

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200114231813080.png" alt="image-20200114231813080" style="zoom:33%;" />

迭代的思路是

a = a + b

b = original a

counter = counter + 1

until counter reaches n

```mua
make "fib_iter [
	[a b counter]
	[
		if eq :counter 0
		[output :b]
		[output fib_iter (:a + :b) :a (:counter - 1)]
	]
]
```



### Pascal's triangle

```
      1
    1   1
  1   2   1
1   3   3   1
```

```mua
//recursion
make "pascal [
	[n k]
	[
		if eq :n :k
      [output 1]
      [
      	if eq :k 0
      	[output 1]
      	[
        	output add pascal (:n-1) (:k-1) pascal (:n-1)(:k)
      	]
      ]
	]
]
```

迭代的话可以考虑用阶乘来计算二项式



### Exponentiation Calculation

$b^n=b*b^{n-1}$

$b^0=1$

```mua
make "exp [
	[b n]
	[
		if lt :n 1
		[output 1]
		[output (:b * exp b (:n-1))]
  ]
]
```



快速幂

如果n是偶数

$b^n=(b^{n/2})^2$

如果n是奇数

$b^n=b*b^{n-1}$



```mua
//递归版本
make "fast_exp [
	[b n]
	[
		if eq :n 0
			[output 0]
			[
				if even? :n
					[output square fast_exp (:n/2)]
					[output (b * fast_exp (:n-1))]
			]
	]
]
make "even? [
	[n]
	[
		if eq (:n % 2) 0
			[output "true]
			[output "false]
	]
]
make "square [
	[n]
	[output (:n*:n)]
]
```

迭代版本



```mua
make "fast_exp_iter [
	[res b n]
	[
		if eq :n 0
			[output 0]
			[
				if even? :n
					[
						output fast_exp_iter (:res * :res)  b (:n/2)
          ]
          [
          	output fast_exp_iter (:b * :res) b (:n-1)
          ]
			]
	]
]
```



### GCD

```mua
make "gcd [
	[a b]
	[
		if eq :b 0
      [output :a]
      [output gcd :b (:a%:b)]
	]
]
```



### 素数检测

```mua
make "prime [
	[n]
	[output eq smallest_divisor :n :n]
]
make "smallest_divisor [
	[n]
	[output find_divisor :n 2]
]
make "find_divisor [
	[n test_divisor]
	[
		if gt square :test_divisor n
		[output n]
		[
			if divides? :test_divisor :n
			[output :test_divisor]
			[
				output find_divisor n (test_divisor+1)
			]
		]
	]
]
make "divides? [
	[test_divisor n]
	[output (:n%:test_divisor)]
]

```



### 求和iterative

```mua
//递归版本
make "sum_integers [
	[a b]
	[
		if gt :a :b
			[output 0]
			[
				output (:a+ sum_integers (:a+1) :b)
			]
	]
]
```



```mua
make "sum [
	[term a next b]
	make "iter [
		[a result]
    [
      if gt :a :b
        [output result]
        [output iter next :a add term :a :result]
    ]
	]
	output iter :a 0
]

```

<a href="http://hcoona.github.io/Functional-Programming/tail-recursion-cps-and-recursion-to-loop/">excellent article</a>

手动优化尾递归

1. 首先，把上面尾递归代码抄过来。
2. 将参数提取出来，成为迭代变量。原来的参数则用来初始化迭代变量。
3. 创建一个迭代函数，迭代函数只用来只用来更新迭代变量。
4. 将原来函数的里面所代码（不包括我们上面的迭代函数和迭代变量初始化）包在一个 while (true) 迭代循环里面。Tip：加一个 label 用于标识循环。
5. 递归终止的 return 不变，尾递归的 return 替换成迭代函数，并且 continue 掉上面的迭代循环。Tip：上面的 label 在这里用



编译器做的事情是：检测到一个尾递归后，在函数前加上 `start` ，函数结尾处加上 `goto start`，就实现了将尾递归转化为迭代。