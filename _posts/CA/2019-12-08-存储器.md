---
title: "CA--storage"
tags: Computer-Architecture
key: page-CAstorage
mathjax: true
excerpt_type: html
author: Chenlu Miao
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(34, 139, 87 , .4), rgba(139, 34, 139, .4))'
  background_image:
    src: https://miaochenlu.github.io/picture/IMG_275920191201-193115.png
---

<img src="https://miaochenlu.github.io/picture/image-20191208210849569.png" alt="image-20191208210849569" style="zoom:50%;" />

<!--more-->



# 1. Introduction

<img src="https://miaochenlu.github.io/picture/image-20191208134608723.png" alt="image-20191208134608723" style="zoom:50%;" />



## 1.1 缓存性能

CPU execution time

$$=(CPU\, clock\, cycles + Memory\, stall\, cycles)\times Clock\, cycle\, time$$

{:.warning}

这里CPU clock cicles包括handletime  cache hit/miss的时间

<img src="https://miaochenlu.github.io/picture/image-20191208135106480.png" alt="image-20191208135106480" style="zoom:60%;" />

<img src="https://miaochenlu.github.io/picture/image-20191208135244903.png" alt="image-20191208135244903" style="zoom:60%;" />



看一道例题

> a computer with CPI=1 when cache hit.  
>
> 50% instructions are loads and stores;
>
>  2% miss rate, 25 cc miss penalty;
>
> **Q:** how much faster would the computer be if all instructions were cache hits?

Answer:

1. always hit:

CPU execution time = (CPU clocks cycles + Memory stall cycles) * clock cycle

=$$(IC \times CPI + 0) \times clock\,cycle$$

=$$IC \times clock\, cycle$$

<br/>

2. with misses

Memory stall cycles

= $IC \times \frac{Memory\, accesses}{Instruction}\times Miss\, rate\times Miss\, penalty$

=$IC\times(1+0.5)\times 0.02\times 25$

=$IC\times 0.75$

{:.warning}

memory accesses=1.5是因为执行任何一条指令都要访问memory取指令，并且50%的指令是load, store 因此 1+0.5=1.5

CPU execution time = (CPU clocks cycles + Memory stall cycles) $\times$ clock cycle

=$(IC\times 1.0+IC\times 0.75)\times$clock cycle

=$1.75\times $clock cycle

所以比值是1.75



## 1.2 4个存储器层次结构问题

Q1: Where can a block be placed in the upper level? (block placement)

Q2: How is a block found if it is in the upper level? (block identification)

Q3: Which block should be replaced on a miss? (block replacement)

Q4: What happens on a write? (write strategy)

<img src="https://miaochenlu.github.io/picture/2019-12-08.7.42.32.png" alt="截屏2019-12-08下午7.42.32" style="zoom:67%;" />

<img src="https://miaochenlu.github.io/picture/image-20191208194519623.png" alt="image-20191208194519623" style="zoom: 67%;" />



### A. Write Strategy

`Write hit`{:.success}

* write-through: info is written to both the block in the cache and to the block in the lower-level memory
* write-back: info is written only to the block in the cache;  to the main memory only when the modified cache block is replaced[dirty bit]

`Write miss`{:.error}

* Write allocate: data at the missed-**write** location is loaded to cache, followed by a **write**-hit operation  
* No-write allocate[write around]: data at the missed-**write** location is not loaded to cache, and is written directly to the backing store.  ;  *until the program tries to read the block, the data is loaded to cache;*



<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191208201918610.png" alt="image-20191208201918610" style="zoom:50%;" />

1. No-Write allocate:  4 misses + 1 hit

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191208202025669.png" alt="image-20191208202025669" style="zoom:50%;" />

2. Write allocate:  2 misses + 3 hits

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191208202722945.png" alt="image-20191208202722945" style="zoom:50%;" />

# 2. 缓存性能



### Hit or Miss: How long will it take?

Average memory access time = Hit time + Miss rate x Miss penalty

* **Example**

> 16KB instr cache + 16KB data cache;
>
>  or, 32KB unified cache;
>
>  36% data transfer instructions;
>
>  (load/store takes 1 extra cc on unified cache)
>
> 1 CC hit; 200 CC miss penalty;

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191208204528711.png" alt="image-20191208204528711" style="zoom:30%;" />

> **Q1:** split cache or unified cache has lower miss rate? 

Answer:

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191208204804983.png" alt="image-20191208204804983" style="zoom:40%;" />

1. split cache

16KB instruction Miss rate

​		= $$\frac{3.82}{1000}/1=0.004$$

16KB data miss rate

​		=$$\frac{40.9}{1000}/0.36=0.114$$

assume 74% of memory accesses are instruction references

Overall miss rate

​		=$$(74\%\times 0.004)+(26\%\times 0.114)=0.0326$$

2. unified cache

Miss rate

=$\frac{43.3}{1000}/(1.0+0.36)=0.0318$$

> **Q2:** average memory access time?

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191208205644462.png" alt="image-20191208205644462" style="zoom:40%;" />

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191208205754992.png" alt="image-20191208205754992" style="zoom:40%;" />



## 2.1 存储器平均访问时间与处理器性能



# 3. 6中基本的缓存优化

