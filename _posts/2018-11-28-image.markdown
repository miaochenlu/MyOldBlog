---

layout: post

title: "Image Processing"

date: 2018-11-28 12:21:05 +0800

categories: jekyll update

---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


## **图像插值算法：**  
### 1、最邻近插值  
为了计算⼏何变换后新图像中某⼀点P’处的像
素值，可以⾸先计算该⼏何变换的逆变换，计算出
P’所对应的原图像中的位置P。通常情况下，P的位
置不可能正好处在原图像的某⼀个像素位置上（即
P点的坐标通常都不会正好是整数）。寻找与P点最
接近的像素Q，把Q点的像素值作为新图像中P’点的
像素值。

<img src="http://miaochenlu.github.io/picture/picture20181128interpolation.png">

### 2、线性插值
<!-- $$g_3 = \frac{g_2-g_1}{x_2-x_1}(x_3-x_1)+g_1$$    -->

<table border="0"><tr>
<td><img src="http://miaochenlu.github.io/picture/picture20181128linear.png" width = "400" border="0"></td>
<td><img src="http://miaochenlu.github.io/picture/picture20181128 linearequation.png" width = "200" border="0"></td>
</tr></table>
<!-- <img src="http://miaochenlu.github.io/picture/picture20181128linear.png" height = "200" width = "200">
<img src="http://miaochenlu.github.io/picture/picture20181128 linearequation.png"> -->

### 3、双线性插值
<img src="http://miaochenlu.github.io/picture/picture20181205bilinear.png">
<img src="http://miaochenlu.github.io/picture/picture20181205bilinearequa.png">

## Simple geometric transformation
### 1、Translation 平移 
<img src="http://miaochenlu.github.io/picture/picture20181205translation.png" width = "300">  
其逆变换为
<img src="http://miaochenlu.github.io/picture/picture2018translationreverse.png">
根据其逆变换，我们可以知道平移后的图像中的像素对应的在原来图像中的坐标

```c
void translation(U8* pdata,U32 bitCountPerPix,int width,int height,int xoffbit,int yoffbit,const char*filename )
{
    int translationwidth = width + abs(xoffbit);
    int translationheight = height + abs(yoffbit);
    U32 bmppitch = ((translationwidth*bitCountPerPix + 31) >> 5) << 2;
    U8 BytePerPix = bitCountPerPix >> 3;
    U8* copydata = (U8*)malloc(bmppitch*translationheight);
    memset(copydata, 255, bmppitch*translationheight);
    U32 originpitch = width * BytePerPix;
    U32 pitch = translationwidth * BytePerPix;
    int h,w;
    for(h = translationheight - 1; h >=yoffbit ; h--) {
        for(w = xoffbit; w < translationwidth; w++) {
            copydata[h*pitch+w*BytePerPix+0] = pdata[(h-yoffbit)*originpitch+(w-xoffbit)*BytePerPix+0];
            copydata[h*pitch+w*BytePerPix+1] = pdata[(h-yoffbit)*originpitch+(w-xoffbit)*BytePerPix+1];
            copydata[h*pitch+w*BytePerPix+2] = pdata[(h-yoffbit)*originpitch+(w-xoffbit)*BytePerPix+2];
        }
    }
    GenerateBmpFile(copydata,bitCountPerPix,translationwidth,translationheight,filename);
    free(copydata);
}
```
$$b=a_n·2^n+a_{n-1}·2^{n-1}+\cdots+a_1·2^1+a_0$$

[jekyll-docs]: https://jekyllrb.com/docs/home

[jekyll-gh]: https://github.com/jekyll/jekyll

[jekyll-talk]: https://talk.jekyllrb.com/
