---

layout: post

title: "Image Processing"

date: 2018-11-28 12:21:05 +0800

categories: jekyll update

---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>



## **Basic Concept**
### Lens

<img src="http://miaochenlu.github.io/picture/picture20181222lens.png">

A lens focuses light onto the film   
– There is a specific distance at which objects are "in
focus"    
    * other points project to a "circle of confusion" in the image   
– Changing the shape of the lens changes this distance

### aperture(光圈)

<table border="0"><tr>
<td><img src="http:///miaochenlu.github.io/picture/picture20181222aperture.png" width = "600" border="0" ></td>
<td><p>
<b>Why not make the aperture as small as possible?</b> <br>
* The quantity of light is too small. <br>
* Lead to diffraction if the aperture is too small.  <br>
* Difficult to control.
</p></td>
</tr></table>


### depth of field(景深)
<img src = "http://miaochenlu.github.io/picture/picture20181222depth.png">

It can be seen from the picture that changing the aperture size affects depth of field.  
– A smaller aperture increases the range in which the
object is approximately in focus


## **Spatial Filtering**
### **Linear smoothing filter**
* **Concept**    
The output of the linear smoothing filter is the mean value of the pixels in the mask. It’s also called mean filter.
* **application**   
Mean filter is mainly used for subtle detail removal,
namely, eliminating the unwanted region smaller than the mask.  
* **general equation**     

$$
    g(x,y)=\frac{\Sigma_{s=-a}^{s=a}\Sigma_{t=-b}^{t=b}w(s,t)f(x+s,y+t)}{\Sigma_{s=-a}^{s=a}\Sigma_{t=-b}^{t=b}w(s,t)}
$$

<table border="0"><tr>
<td><img src="http://miaochenlu.github.io/picture/picture20181210nonweight.png" width = "300" border="0" ></td>
<td><img src="http://miaochenlu.github.io/picture/picture20181210weight.png" width = "300" border="0"></td>
</tr></table>

### **Statistical sorting filter**
* **Concept**  
Statistical filter is a kind of nonlinear spatial filter, whose response is based on the **sorting of pixel value in the mask window**.The value of center pixel depends on the sorting result in the window.  
The most popular statistical filter is median filter.
* **Median filter**  
    * Subsititute the center pixel with the median value in the neighborhood.  
    * Provide excellent de-noise ability, which introduce less blurring than the mean filter.
    * Be effective to deal with the pulse noise(or pepper noise) because this kind of noise looks like bright or dark point in the image.  
* **example**
In a $3 \times 3$ neighborhood, there are a series pixel values:  
(21, 100, 99, 22, 20, 102, 97, 101)  
After sorting:  
(20, 21, 22, 97, 100, 101, 102)  
<img src="http://miaochenlu.github.io/picture/picture20191217sortfilter.png">  

### **Bilateral filter**
* **Gereral idea** 
An image has two main characteristics
    * The space domain S, which is the set of possible
    positions in an image. This is related to the
    resolution, i.e., the number of rows and columns in
    the image.
    * The intensity domain R, which is the set of
    possible pixel values. The number of bits used to
    represent the pixel value may vary. Common pixel
    representations are unsigned bytes (0 to 255) and
    floating point  

Every sample is replaced by a weighted average of its neighbors,  These weights reflect two forces
* How close are the neighbor and the center sample, so that
larger weight to closer samples,
* How similar are the neighbor and the center sample –
larger weight to similar samples.   
All the weights should be normalized to preserve the
local mean.

```c
void Bilateral(U8 *pdata, U8 bitCountPerPix, U32 width, U32 height,double sigma_s, double sigma_r, const char *filename)
{
    int i, j;
    int maskh,maskw;
    U8 BytePerPix = bitCountPerPix >> 3;
    U32 pitch = width * BytePerPix;

    U32 bmppitch = ((width * bitCountPerPix + 31) >> 5) << 2;
    U8 *copypdata = (U8*)malloc(height*bmppitch);
    memset(copypdata, 0, bmppitch*height);
    memcpy(copypdata, pdata, height*bmppitch);

    double wred, wblue, wgreen;
    double ws;
    double wr_green, wr_blue, wr_red;
    double pixelgreen, pixelblue, pixelred;
    for(j = height - 22; j >= 20; j--) {
        for(i = 20; i <= width - 22; i++) {
            wred = 0; wblue = 0; wgreen = 0; 
            ws = 0; 
            wr_green = 0; wr_blue = 0; wr_red = 0;
            pixelgreen = 0; pixelblue = 0; pixelred = 0;

            for(maskh = j + 21; maskh >= j - 20; maskh--) {
                for(maskw = i - 20; maskw <= i + 21; maskw++) {
                    ws = exp(-((maskh-j)*(maskh-j)+(maskw-i)*(maskw-i))/(2*sigma_s*sigma_s));
                    double differencegreen = (pdata[maskh*pitch + maskw*BytePerPix + 0]-pdata[j*pitch + i*BytePerPix + 0]);
                    double differenceblue = (pdata[maskh*pitch + maskw*BytePerPix + 1]-pdata[j*pitch + i*BytePerPix + 1]);
                    double differencered = (pdata[maskh*pitch + maskw*BytePerPix + 2]-pdata[j*pitch + i*BytePerPix + 2]);
                    wr_green = exp(-(differencegreen*differencegreen)/(2*sigma_r*sigma_r));
                    wr_blue = exp(-(differenceblue*differenceblue)/(2*sigma_r*sigma_r));
                    wr_red = exp(-(differencered*differencered)/(2*sigma_r*sigma_r));
                    wgreen += ws * wr_green;
                    wblue += ws * wr_blue;
                    wred += ws * wr_red;
                    pixelgreen += wr_green * ws * pdata[maskh*pitch + maskw*BytePerPix + 0];
                    pixelblue += wr_blue * ws * pdata[maskh*pitch + maskw*BytePerPix + 1];
                    pixelred += wr_red * ws * pdata[maskh*pitch + maskw*BytePerPix + 2];
                }
            }
            copypdata[j*pitch + i*BytePerPix + 0] = pixelgreen / wgreen;
            copypdata[j*pitch + i*BytePerPix + 1] = pixelblue / wblue;
            copypdata[j*pitch + i*BytePerPix + 2] = pixelred / wred;

        }
    }
 
    GenerateBmpFile(copypdata,bitCountPerPix, width, height, filename);
    free(copypdata);
}
```

Result:  
<img src="http://miaochenlu.github.io/picture/picture20181222bila.png">

## **图像插值算法：**  
### 1、最邻近插值  
为了计算⼏何变换后新图像中某⼀点P’处的像
素值，可以⾸先计算该⼏何变换的逆变换，计算出
P’所对应的原图像中的位置P。通常情况下，P的位
置不可能正好处在原图像的某⼀个像素位置上（即
P点的坐标通常都不会正好是整数）。寻找与P点最
接近的像素Q，把Q点的像素值作为新图像中P’点的
像素值。

<img src="http://miaochenlu.github.io/picture/picture20181128interpolation.png">

### 2、线性插值
<!-- $$g_3 = \frac{g_2-g_1}{x_2-x_1}(x_3-x_1)+g_1$$    -->

<table border="0"><tr>
<td><img src="http://miaochenlu.github.io/picture/picture20181128linear.png" width = "400" border="0"></td>
<td><img src="http://miaochenlu.github.io/picture/picture20181128 linearequation.png" width = "200" border="0"></td>
</tr></table>


### 3、双线性插值
<img src="http://miaochenlu.github.io/picture/picture20181205bilinear.png">
<img src="http://miaochenlu.github.io/picture/picture20181205bilinearequa.png">

## Simple geometric transformation
### 1、Translation 平移 

<img src="http://miaochenlu.github.io/picture/picture20181205translation.png" width = "300">  

其逆变换为
<img src="http://miaochenlu.github.io/picture/picture2018translationreverse.png">  


根据其逆变换，我们可以知道平移后的图像中的像素对应的在原来图像中的坐标


```c
void translation(U8* pdata,U32 bitCountPerPix,int width,int height,int xoffbit,int yoffbit,const char*filename )
{
    int translationwidth = width + abs(xoffbit);
    int translationheight = height + abs(yoffbit);
    U32 bmppitch = ((translationwidth*bitCountPerPix + 31) >> 5) << 2;
    U8 BytePerPix = bitCountPerPix >> 3;
    U8* copydata = (U8*)malloc(bmppitch*translationheight);
    memset(copydata, 255, bmppitch*translationheight);
    U32 originpitch = width * BytePerPix;
    U32 pitch = translationwidth * BytePerPix;
    int h,w;
    for(h = translationheight - 1; h >=yoffbit ; h--) {
        for(w = xoffbit; w < translationwidth; w++) {
            copydata[h*pitch+w*BytePerPix+0] = pdata[(h-yoffbit)*originpitch+(w-xoffbit)*BytePerPix+0];
            copydata[h*pitch+w*BytePerPix+1] = pdata[(h-yoffbit)*originpitch+(w-xoffbit)*BytePerPix+1];
            copydata[h*pitch+w*BytePerPix+2] = pdata[(h-yoffbit)*originpitch+(w-xoffbit)*BytePerPix+2];
        }
    }
    GenerateBmpFile(copydata,bitCountPerPix,translationwidth,translationheight,filename);
    free(copydata);
}
```



[jekyll-docs]: https://jekyllrb.com/docs/home

[jekyll-gh]: https://github.com/jekyll/jekyll

[jekyll-talk]: https://talk.jekyllrb.com/
