---
title: NP完全性
tags: NP
key: page-NP
---








# <center>NP完全性</center>

# 1 绪论

在证明一个问题是NP完全问题时，需要用到三个关键概念

* ## 判定问题与最优化问题

什么是最优化问题？

> 问题的每一个可行解都有一个关联的值，我们希望找出具有最佳关联值的可行解  
>
> 例如：最短路径问题中，已知无向图G以及定点u,v ，要求找到u,v之间经过边数目最少的一条路径。这里一个可行解就是一条路径，路径的经过边数就是关联值。

什么是判定问题？

> 问题的答案只有“是”和“否”（1或者0）

<br/>

我们要讲这两个问题的概念是因为NP完全性不直接适用于最优化问题，但适用于判定问题

但是，我们可以将最优化问题转换成判定问题，看下面这个例子

> 给定的有向图G，顶点u,v，一个整数k, 问：在u,v之间是否存在一条至多包含k条边的路径
>
> 如果回答是“是”  
>
> 不妨再问：在u,v之间是否存在一条至多包含k/2条边的路径
>
> 这样一直问下去，就可以得到结果

<br/>



* ## 归约

我们引入归约的概念来衡量一个问题到底有多难。  

先来提出一些概念  



实例：我们称某一特定问题的输入为该问题的**实例**(instance)

> 比如PATH问题中，实例是一个特定的图G，点u,v，一个整数k

<br/>

我们有一个判定问题**A**，希望能在多项式时间内解决。同时我们也有一个问题B，我们知道如何在多项式时间内解决。 

假设有一个过程，可以将A的任何实例 $\alpha$转化成B的实例 $\beta$，且 $\beta$具有以下特征

* 转换操作需要多项式时间
* 两个实例的解相同（$\alpha$的解是“是”，当且仅当$\beta$的解也是“是”）

上述过程我们称为：***多项式时间归约算法***

<br/>

有了上述算法，我们就可以得出在多项式时间内解决A的方法

1. 给定问题A的实例$\alpha$，利用**多项式时间归约算法**，转换成问题B的实例 $\beta$
2. 在实例 $\beta$上，运行B的多项式时间判定算法
3. 将 $\beta$的解作为 $\alpha$的解  

这个算法如下图所示 

 <center><img src="https://miaochenlu.github.io/picture/image-20190918104628691.png" alt="image-20190918104628691" style="zoom:50%;" /></center>

利用多项式时间归约算法，我们可以比较两个问题的难度

>我们有一个判定问题A，已知不存在多项式时间算法  
>
>假设我们可以用有一个多项式时间的归约将A的实例转换成问题B的实例
>
>那么问题B不存在多项式时间算法（也就是B问题不会简单于A问题）

证明如下：  

> 用反证法: 假设B问题存在多项式时间算法，那么用之间的算法，我们可以得出A问题可以在多项式时间内解决，矛盾！

<br/>

* ## 第一个NP完全问题

归约这个技巧依赖于“已知一个NP完全问题”去解决另一个不同的“NP完全问题”（这样才能比较难度🐎）  

第一个NP完全问题是电路可满足性问题



# 2 多项式时间

## 2.1 抽象问题

我们先对问题做一个形式化定义：

> 抽象问题Q为在问题实例集合$I$ 和问题解集合S上的一个二元关系

因为NP完全性聚焦于判定问题，所以我们可以把抽象的判定问题看作是从实例集$I$映射到解集$\{0,1\}$上的一个函数

<br/>

（对计算机来说我们脑子里想的图啊，函数啊什么的都是抽象的，这些问题才是抽象问题，编码才是具体的

## 2.2 编码

怎么求解一个抽象问题，显然如果要计算机去理解问题实例，我们应该将实例编码。通过这种编码，我们将计算机认为的抽象问题转换成了他擅长的编码形式的具体问题。

抽象对象集合S的编码是从S到二进制串集合的映射e

> 比如把自然数$N=\{0,1,2,\cdots\}$编码为串$\{0,1,10,11,\cdots\}$
>
> $e(17)=10001$

多边形、图、函数等都可以编码

<br/>

怎么描述一个具体问题多项式时间可解呢？  



> 提供长度为$n=\vert{x}\vert$ 的一个问题实例i, 算法可以在$O(T(n))$时间内产生问题的解，我们就说算法在$O(T(n))$时间内解决了该具体问题



可以利用编码将抽象问题映射到具体问题上

> 如果给定一个抽象判定问题Q，其映射为：实例集合$I\mapsto \{0,1\}$
>
> 利用编码：$e:I\mapsto \{0,1\}^*$，可以得到该问题相关的具体判定问题，记为$e(Q)$
>
> 如果一个抽象问题实例$i\in I$的解为$Q(i)\in\{0,1\}$，则具体问题实例$e(i)\in\{0,1\}^*$的解也是$Q(i)$

<br/>

*我们希望能通过编码的方式把多项式时间可解性的定义从具体问题扩展到抽象问题，但是我们希望的是**这个定义与任何特定的编码无关（求解一个问题的效率不应该依赖于问题的编码）***



但是：很遗憾，求解一个问题的效率对于问题的编码有很强的依赖性



看一个例子：  

> 假定把一个k作为一个算法的唯一输入，并且假设这个算法运行的效率是$\Theta(k)$  
>
> 如果提供的整数k是一元的（由k个1组成的串，如1=1，2=11，3=111），那么对于长度为n的输入(也相当于k=n)，那么该算法的运行时间为多项式时间$O(n)$  
>
> 但是如果采用二进制来表示整数k（即1=1，2=10，3=11），那么输入长度为$n=\lfloor logk\rfloor+1$，那么这个算法的运行时间$\Theta(k)=\Theta(2^n)$   

一个事实，如果不采用一元编码，采用其他编码，如二元编码、三元编码，则对问题的求解几乎没有影响

<br/>

<br/>

#### 多项式时间可计算的函数

> 对一个函数  $f:\{0,1\}^*\mapsto\{0,1\}^*$  ，如果存在一个多项式时间的算法A，他对任意给定的输入,  $x\in\{0,1\}^*$  ,都能产生输出  $f(x)$ 

对某个问题实例集$I$，如果存在两个多项式时间可计算的函数$f_{12}$和$f_{21}$满足  



$$\forall x\in I,f_{12}(e_1(i))=e_2(i)且f_{21}(e_2(i))=e_1(i)$$



我们就说这两种编码是多项式相关的



<!--more-->

------









