---
layout: post

title: "HTM fighting!"

date: 2019-09-25 15:43:05 +0800

categories: jekyll update

---



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>



# 2019.09.25

Read DHTM and have a general idea!



## general idea

NVM, persistent, demand crash recoverability$\Rightarrow$ACID Transactions$\Rightarrow$Software based signigicant performance overheads.  

Propose DHTM.  

Techniques:  

* leverages a ***commercial HTM*** to provide ***atomic visibility*** and extends it with hardware support for ***redo logging*** to provide ***atomic durability***
* extend the supported ***transaction size*** (from being L1-limited to LLC- limited

Result:DHTM outperforms the state-of- the-art by an average of 21% to 25% 

<br/>

## Dive into details

### 1 What is the problem?

#### 1.1 New things came out, brought opportunities

NVM's emergence provides a high-bandwidth and low-latency alternative for durability.   

##### New challenge

It's good, but could it be better? What if a crash happens? Could it still guarantee durability?  



#### 1.2 Looking for methods around us

When referring crash consitent, we can think about transactions in database that provide ACID guarantees.  

But these database implementations perform badly when applied to in-memory settings.

This lead to a question:

> **How fast can we enforce ACID in the presence of fast persistent memory? **



### 2 Others' methods and their drawbacks.

#### first class

Techniques 

> Support atomic durability via software logging by employing flushing and ordering instructions.

Drawbacks 

> significant performance cost

*why????????*



#### second class

Techniques

> * Employ hardware support for atomic durability
>
> **OR**
>
> * leverage hardware support for ordering to guarantee atomic durability

#### third class

techniques

> Use HTM to support atomic visibility

Drawbacks

> * Current HTM only support small transactions
>
> L1 limitation significantly limit usability and efficiency for ACID transactions
>
> * HTM systems only provide ACI guarantees



#### Fourth class

techniques

> supports ACID by integrating HTM with hardware support for durability

Drawback

> PTM (the only proposal in this class) not only introduces significant changes to the cache hierarchy, but also continues to suffer from the L1 limitation.

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20190925202905366.png" alt="image-20190925202905366" style="zoom:80%;" />





### 3 Our Approach's sketch

#### *3.1 Goal*

> * Primary: design an HTM that can support ACID transactions efficiently
> * extend the supported transaction size by supporting overflows from the L1 cache to the last level cache (LLC) without adding significant complexity to the coherence pro- tocol or the LLC

#### *3.2 techniques*

Propose DHTM

> * Integrate commercial HTM with hardware support for ***redo logging***. We also propose a mechanism for **coalescing log entries** to reduce the required memory bandwidth.
>
> atomic visibility---->HTM 
>
> Atomic durability---> architectural support for transparently and efficiently writing redo log entries to a durable transaction log maintained in persistent memory
>
> * Leveraging the same logging infrastructure for also supporting ***L1 overflows to extend supported transaction size***. We accomplish this with only ***minor changes*** to coherence protocol.





### 4 Related Background

#### *A Hardware Transactional Memory*

##### A.1 functionalities

> * Buffering the speculative state
> * tracking read sets and detecting conflicts
> * tracking write sets and detecting conflicts





##### A.2 techniques

> * buffer speculative state in ***private caches*** (typically L1). Each L1 cache line is associated with a ***write bit*** to keep track of the write set of a transaction.
>
>  If a cache line belonging to the write set of a transaction is evicted from the L1, the transaction is aborted.---L1 limited
>
> 





<a href="https://www.cc.gatech.edu/~milos/garzaran_hpca03.pdf">Tradeoffs in Buffering Memory State for Thread-Level Speculation in Multiprocessors </a>













