---
layout: post

title: "HTM fighting!"

date: 2019-09-25 15:43:05 +0800

categories: jekyll update

---



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>



# 2019.09.25

Read DHTM and have a general idea!



## general idea

NVM, persistent, demand crash recoverability$\Rightarrow$ACID Transactions$\Rightarrow$Software based signigicant performance overheads.  

Propose DHTM.  

Techniques:  

* leverages a ***commercial HTM*** to provide ***atomic visibility*** and extends it with hardware support for ***redo logging*** to provide ***atomic durability***
* extend the supported ***transaction size*** (from being L1-limited to LLC- limited

Result:DHTM outperforms the state-of- the-art by an average of 21% to 25% 

<br/>

## Dive into details

### 1 What is the problem?

#### 1.1 New things came out, brought opportunities

NVM's emergence provides a high-bandwidth and low-latency alternative for durability.   

##### New challenge

It's good, but could it be better? What if a crash happens? Could it still guarantee durability?  



#### 1.2 Looking for methods around us

When referring crash consitent, we can think about transactions in database that provide ACID guarantees.  

But these database implementations perform badly when applied to in-memory settings.

This lead to a question:

> **How fast can we enforce ACID in the presence of fast persistent memory? **



### 2 Others' methods and their drawbacks.

#### first class

Techniques 

> Support atomic durability via software logging by employing flushing and ordering instructions.

Drawbacks 

> significant performance cost

*why????????*



#### second class

Techniques

> * Employ hardware support for atomic durability
>
> **OR**
>
> * leverage hardware support for ordering to guarantee atomic durability

#### third class

techniques

> Use HTM to support atomic visibility

Drawbacks

> * Current HTM only support small transactions
>
> L1 limitation significantly limit usability and efficiency for ACID transactions
>
> * HTM systems only provide ACI guarantees



#### Fourth class

techniques

> supports ACID by integrating HTM with hardware support for durability

Drawback

> PTM (the only proposal in this class) not only introduces significant changes to the cache hierarchy, but also continues to suffer from the L1 limitation.

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20190925202905366.png" alt="image-20190925202905366" style="zoom:80%;" />





### 3 DHTM  sketch

#### *3.1 Goal*

> * Primary: design an HTM that can support ACID transactions efficiently
> * extend the supported transaction size by supporting overflows from the L1 cache to the last level cache (LLC) without adding significant complexity to the coherence pro- tocol or the LLC

#### *3.2 techniques*

Propose DHTM

> * Integrate commercial HTM with hardware support for ***redo logging***. We also propose a mechanism for **coalescing log entries** to reduce the required memory bandwidth.
>
> atomic visibility---->HTM 
>
> Atomic durability---> architectural support for transparently and efficiently writing redo log entries to a durable transaction log maintained in persistent memory
>
> * Leveraging the same logging infrastructure for also supporting ***L1 overflows to extend supported transaction size***. We accomplish this with only ***minor changes*** to coherence protocol.





### 4 Related Background

#### *A Hardware Transactional Memory*

##### A.1 functionalities

> * Buffering the speculative state
> * tracking read sets and detecting conflicts
> * tracking write sets and detecting conflicts





##### A.2 techniques

> * buffer speculative state in ***private caches*** (typically L1). 
>
> Multiprocessor executes instructions in parallel, not serially.  So they do not know if they executes instructions in that order is correct. Thus, we need to buffer speculative states. 
>
> * Conflict detection 
>
> Each L1 cache line is associated with a ***write bit*** and a **read bit** to keep track of the **write and read** set of a transaction.
>
> 
>
> Write:  
>
>  If a cache line belonging to the write set of a transaction is evicted from the L1, the transaction is aborted.---L1 limited. 
>
> supporting overflows from the private L1 caches to reduce the design complexity---LLC limited. 
>
> Read:  
>
> Read bit is set when corresponding cache line is read within a transaction. When such a cache line is evicted, the transaction is not aborted,  but the address of the cache line is added to a *read- set overflow signature* (also maintained in the L1 cache). Thus, the read set of a transaction is tracked using both the read bits in the L1 cache and the read-set overflow signature.
>
> 
>
> When the L1 receives an invalidate forwarding request for a cache line in the write set, a conflicted is detected, triggering an abort of one of the transactions.
>
> ​		which to abort? ----requester wins policy & (first) writer wins policy
>
> 

<a href="https://www.cc.gatech.edu/~milos/garzaran_hpca03.pdf">Tradeoffs in Buffering Memory State for Thread-Level Speculation in Multiprocessors </a>



**Overflow Support**

It is about how to deal with the case that write set overflows from private caches.



Techniques:

version Management 

<a href="https://en.wikipedia.org/wiki/Version_control">version control on software</a>



> A. lazy version(buffer overflow)
>
> Allow the write set to overflow into a redo log. 
>
> On a commit, these values need to be copied in-place. Consequently, these techniques stall any transaction that conflicts with a committed transaction that is still copying its updates in-place.
>
> B. eager version(write directly into memory)
>
> Allow the write to overflow in-place in memory but maintain an undo log that is applied in case of an abort. Therefore, they have to stall transactions that conflict with an aborting transaction that is applying its undo log.
>
>  
>
> Similiar to ***write back*** and ***write through*** strategies we learned in computer organization.



However, stalling adds significant design complexity as it requires support for retrying requests using a NACK based coherence protocol.

What is "nack"?

 <a href="https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)">nack</a> 

It means that if someone request sth, you have to come out a mechanism to reject.

<br/>

##### Our method

> Goal
>
> > support overflows from the L1 cache to the LLC while maintaining the simplicity of an RTM like protocol
>
> Techniques
>
> > * performs data updates in the cache and eager conflict detection in the same way as RTM.
> >
> > * maintains a redo log in memory for atomic durability and also supports write set overflows to the LLC with minor modifications to the coherence protocol





#### ***B. Crash Consistency***

Use ***write-ahead logging***: the log entries be made persistent before data values can persist.

It suffers from significant performance overhead. To mitigate this overhead, prior work has proposed 

* hardware support for accelerating ordering

Still need memory barrier between log writes and data writes

* techniques for transparently performing logging in hardware

The programmer is relieved from the burden of writing log entries







### 5 DHTM DESIGN

#### 5.1 system model

Multicore processor + 2 level cache hierarchy

Cache:

>  private L1 cache + last level cache(LLC)
>
> The private L1s are kept coherent using a MESI directory based coherence protocol with forwarding



#### 5.2 Overview

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20190926232702460.png" alt="image-20190926232702460" style="zoom:50%;" />



We will use logging to achieve durability.

If we want a transaction to be made durable, we need to execute additionally log codes. 

We can see that adding support for durability doubles the write-set size. This is a challenge on current RTM- like HTM designs which already limit the write-set size(L1 limited).



**Our Approach:**

>  integerate hardware based redo logging to an RTM-like HTM and for atomic durability.

DHTM's redo logging mechanism leverages the L1 cache write-back interface to dynamically **write redo log entries to persistent memory** for cache lines being modified within a transaction.

DHTM allows dirty cache lines to overflow from the L1 cache into the LLC without causing an abort.





* ##### DHTM's hardware logging mechanism

* ##### how logging integrates with the HTM

* ##### description on how DHTM manages overflow

$\Downarrow$

#### A. Logging for Durability

>  Ensure atomic durability using write-ahead logging.
>
> This persistent copy is maintained in the form of *log entries* which consist of the address and the old or new version of data.



##### Why Redo Logging?

Comparison:

<a href="http://mlwiki.org/index.php/Undo_Logging">Undo logging</a>

> In volatile transactions, undo logging supports faster commits.
>
> On transaction completion all the in-place updates would have aslready taken place(in the cache). Therefore, commit only require 2 simple steps:
>
> * Discarding the undo log 
> * Flash-clearing the speculative write bits to make the write set visible to other threads.



However, Durable transactions, impose additional constraints.  

Both the undo log and the write set(data) have to be written to persitent memory.

Undo log不能重做，所以新值和log都要写到memory

<br/>

<a href="http://mlwiki.org/index.php/Redo_Logging">Redo logging</a>

> Requires only the ***redo log*** to be written to persitent memoty at commit time.



One drawback of redo logging is that writes are not allowed to overwrite previous values, subsequent reads to those addresses need to be redirected to the redo log.

因为redo log是不能回滚的， 所以不能去修改旧值，要读新值的这些命令需要到redo log中去。



So, using redo log, the most import question we need to answer is: how to rollback?

##### Our Approach

> Overcome the limitation by allowing writes to overwrite previous values in the cache.
>
> 









