---

layout: post

title: "Hashing"

date: 2018-12-18 12:21:05 +0800

categories: jekyll update

---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
inlineMath: [['$','$']]
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

### **散列**  
散列是一种以常数平均时间执行插入、删除、查找的技术。散列函数将关键字映射到从0到TableSize-1范围中的某个数，剩下要解决冲突问题。

### **散列函数**  
* $f(x)$ must be easy to compute and minimizes the number of collisions.
* $f(x)$ should be unbiased. That is, for any x and any i, we have that Probability$(f(x)=i)=1/b$. Such kind of a hash function is called a uniform hash function.

(Note: TableSize = prime number --> good for random integer keys)  
#### 数字关键词的散列函数  
1. 直接定址法: 取关键词的某个线性函数值为散列地址  
$$Hash(key) = a\times key+b$$  
2. 除留余数法  
$$Hash(key) = key\,mod\,p$$  
一般p取素数  
3. 数字分析法: 分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址  
4. 折叠法:把关键词分割成位数相同的几个部分，然后叠加  
$56793524-->542+793+056=1391$取$Hash(56693542)=391$
5. 平方取中法  
$56793542^2=3225506412905764$取$Hash(56793542)=641$  

#### 字符关键词的散列函数
$$\Sigma_{i=0}^{KeySize-1}Key[KeySize-i-1]·32^i$$  

```c
Index Hash(const char *Key, int TableSize)
{
    unsigned int HashVal = 0;
    while(*Key != 0) 
        HashVal = (HashVal << 5) + *Key++;
    return HashVal % TableSize
}
```

### 冲突解决方法
1. 分离链接法  
<table border="0"><tr>
<td><p>将散列到同一个值的所有元素保留到一个表中</p></td>
<td><img src="http://miaochenlu.github.io/picture/picture20181218hash.png" width = "150" border="0"></td>
</tr></table>

<details>
  <summary>Click to expand</summary>

```c
//
//  HashTable.h
//  HashTable.c
//
//  Created by jones on 2018/12/4.
//  Copyright © 2018 jones. All rights reserved.
//

#ifndef HashTable_h
#define HashTable_h
#define ElementType int
struct ListNode;
typedef  struct ListNode *Position;
struct HashTbl;
typedef struct HashTbl *HashTable;

HashTable InitializeTable(int TableSize);
void DestroyTable(HashTable H);
Position Find(ElementType Key, HashTable H);
void Insert(ElementType Key, HashTable H);
ElementType Retrieve(Position P);
#endif /* HashTable_h */


#include <stdio.h>
#include "HashTable.h"
#include <stdlib.h>

struct ListNode
{
    ElementType Element;
    Position Next;
};
typedef Position List;

struct HashTbl {
    int TableSize;
    List *TheLists;//TheLists是指向ListNode的指针的指针
};

int NextPrime(int TableSize)
{
    if(TableSize == 1) return 2;
    int flag;
    for(int j = TableSize;; j++) {
        for(int i = 2; i * i <= TableSize; i++) {
            if(j % i == 0) {
                flag = 0;
                break;
            }
        }
        if(flag == 1) return j;
    }
}
HashTable InitializeTable(int TableSize)
{
    HashTable H;
    int i;
    
    H = (HashTable)malloc(sizeof(struct HashTbl));
    H->TableSize = NextPrime(TableSize);
    //为TheLists分配空间
    H->TheLists = (List*)malloc(sizeof(List) * H->TableSize);
    //设置哑结点
    for(i = 0; i < H->TableSize; i++) {
        H->TheLists[i] = (Position)malloc(sizeof(struct ListNode));
        H->TheLists[i]->Next = NULL;
    }
    
    return H;
}

ElementType Hash(ElementType Key, int TableSize)
{
    return Key % TableSize;
}

Position Find(ElementType Key, HashTable H)
{
    Position P;
    List L;
    //根据Hash结果找出位置
    L = H->TheLists[Hash(Key,H->TableSize)];
    P = L->Next;
    while (P != NULL && P->Element) {
        P = P->Next;
    }
    return P;
    //没找到的话返回的是NULL
}

void Insert(ElementType Key, HashTable H)
{
    Position Pos, NewCell;
    List L;
    
    Pos = Find(Key, H);
    if(Pos == NULL) {
        NewCell = (Position)malloc(sizeof(struct ListNode));
        L = H->TheLists[Hash(Key, H->TableSize)];
        NewCell->Next = L->Next;
        L->Next = NewCell;
    }
}
```
</details>

<div class="ds-thread" data-thread-key="http://miaochenlu.github.io" data-title="请替换成文章的标题" data-url="https://miaochenlu.github.io/jekyll/update/2018/12/18/hashing.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"orangleliu"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>



[jekyll-docs]: https://jekyllrb.com/docs/home

[jekyll-gh]: https://github.com/jekyll/jekyll

[jekyll-talk]: https://talk.jekyllrb.com/
