---
title: "OS--进程"
tags: Operating-system
key: page-OS2

---



# 进程

# 1 概念

不正式地说：进程是执行中的程序（activity entity, a running program)

***进程和程序之间的关系怎么理解***？ 

> 想想一个会做蛋糕的计算机科学家（处理器CPU）正在为他女儿烘焙蛋糕。
>
> 他有制作生日蛋糕的食谱（程序）
>
> 厨房里有需要的原料：面粉、鸡蛋、糖、香草汁（输入数据）
>
> 这个例子中的进程就是计算机科学家阅读食谱，取来原来以及烘焙蛋糕的一系列动作的总和
>
>  
>
> 假设计算机科学家的儿子跑进来，说他被蜜蜂蛰了。
>
> 计算机科学家就记录下自己照着食谱做到哪里了（保存进程的当前状态）
>
> 然后拿出一本急救手册，按照其中的指示处理蛰伤
>
>  
>
> 这里可以看到处理器从一个进程（做蛋糕）切换到另一个高优先级的 进程（实施医疗救治）每个进程有各自的程序（食谱/医疗手册）。蜜蜂蛰伤处理完之后，计算机科学家由回来做蛋糕，从他离开时的那一步做下去。



进程包括：

* 程序代码（文本段（代码段））

* 当前活动（通过程序计数器的值和处理器寄存器的内容来表示）

* 堆栈段（包括临时数据，如：函数参数、返回地址、局部变量）

* 数据段（包括全局变量）

* 堆：进程运行期间动态分配的内存

<center><img src="https://miaochenlu.github.io/picture/1569219440814.png" alt="1569219440814" style="zoom: 67%;" /></center>

<center><img src="https://miaochenlu.github.io/picture/1569656131801.png" alt="1569656131801" style="zoom:50%;" /></center>



## 1.1 进程状态

每个进程可能处于下列状态之一：

* New新的：进程正在被创建
* Running运行：指令正在被执行
* Ready就绪：进程等待分配处理器
* Waiting等待：进程等待某个时间的发生（如I/O完成)
* Terminated终止：进程完成执行

<center><img src="https://miaochenlu.github.io/picture/1569220338728.png" alt="1569220338728" style="zoom:50%;" /></center>



* 运行-->等待：进程发现自己无法继续执行下去。在某些系统中，进程需要执行一个系统调用(block or pause)来进入等待

* 运行-->就绪：由进程调度器引起，调度器认为运行进程占用处理机的时间已经足够长，决定让其他进程占用处理机
* 就绪-->运行：系统已经让其他进程享有了他们应有的CPU时间而重新轮到该进程来占用处理机时间
* 等待-->就绪：当一个进程等待的外部时间发生时（如一些输入到达）



**调度器的主要任务**：哪个进程应当运行，以及它应该运行多长时间。

<center><img src="https://miaochenlu.github.io/picture/1569655670685.png" alt="1569655670685" style="zoom:50%;" /></center>





需要注意的是一次只有一个进程可以在处理器上运行，但是多个进程可以处于就绪或者等待状态



举些例子：

```shell
cat chapter1 chapter2 chapter3 | grep tree
```

第一个进程运行cat，将三个文件链接并输出；第二个进程运行grep，他从输入中选择所有包含单词“tree"的行。

在执行这一行shell时，grep命令可以已经准备好了，但是cat还没有完成，所以grep就会被阻塞



## 1.2 进程控制块(PCB)

为了实现进程模型，操作系统维持一张表格（一个结构数组），即 **进程表**。

每个进程占用一个进程表项（**称为进程控制块（process control block PCB)**）

<br/>

每个进程在操作系统内用进程控制块来表示，他包含很多和一个特定进程相关的信息

<center><img src="https://miaochenlu.github.io/picture/1569221812651.png" alt="1569221812651" style="zoom:70%;" /></center>

信息有：

* 进程状态：new,ready, running,waiting,exit
* 程序计数器：表示进程要执行的下个指令的地址
* CPU寄存器：累加器？堆栈指针？
* CPU调度信息：进程优先级、调度队列的指针、其他调度参数
* 内存管理信息：基址和界限寄存器、页表
* 记账信息：CPU时间、实际使用时间。。。
* I/O状态信息



<img src="/Users/jones/Desktop/miaochenlu.github.io/picture/1569657162817.png" alt="1569657162817" style="zoom:70%;" />



# 2 进程调度

### 2.1 调度队列

* job queue: set of all processes in the system
* ready queue: set of all processes residing in main memory, ready waiting to execute
* device queue: set of processes waiting for an I/O device

队列通常用链表来表示，其头节点指向链表的第一个和最后一个PCB块的指针。每个PCB包括一个指向就绪队列的下一个PCB指针域

#### linux中的进程表示

PCB通过task_struct结构体来表示

```c
pid_t pid;					//process identifier
long state;					//state of the process
unsigned int time_slice;	//scheduling information
struct files_struct *files;	//list of open files
struct mm_struct *mm;		//address space of this process
```

进程的状态通过`long state`表示，在Linux内核中，所有活动的进程是通过`task_struct`的双向链表来表示的。内核为当前正在运行的进程保存了一个指针(current)

<center><img src="https://miaochenlu.github.io/picture/1569657118170.png" alt="1569657118170" style="zoom:67%;" /></center>

内核如何操作呢？

> 如果操作系统想把当前运行的状态值修改为new_state,如果current是当前进程的指针，则
>
> current->state = new_state;
>
> 操作系统同时有其他队列，当进程分配了CPU后，他开始执行并且最终完成，或者被中断，或等待特定时间发生。
>
> 假设进程向一个共享设备（比如磁盘）发送I/O请求，由于系统有其他进程，磁盘可能被其他设备占用，所以该进程需要等待。 （等待特定I/O设备的进程列表称为 **设备队列** 。每个设备有自己的设备队列

如下是就绪队列和各种设备队列图



<center><img src="https://miaochenlu.github.io/picture/1569658254174.png" alt="1569658254174" style="zoom:50%;" /></center>

#### 队列图

<center><img src="https://miaochenlu.github.io/picture/1569658436530.png" alt="1569658436530" style="zoom:50%;" /></center>

讨论进程调度的表示方法：队列图

一些符号的含义：

>  长方形代表队列。队列有两种：就绪队列和设备队列
>
> 圆形表示为队列服务的资源
>
> 箭头表示系统内进程的流向

状态会怎么切换呢？

* 进程发出I/O请求，被加入I/O队列
* 进程创建一个子进程，并等待其结束
* 进程可能会由于中断而强制释放CPU,并放回到就绪队列中

<br/>

### 2.2 调度程序

进程在生命周期中会在各种调度队列之间迁移。操作系统从这些队列中选择进程，这是由调度程序（调度器 scheduler)来执行的

* long-term scheduler
  * selects which processes should be brought into the ready queue.  
  * invoked very infrequently (seconds, minutes)
  * controls the *degree of* *multiprogramming*多道程序的“道” 
  * Most modern operating systems have no long-term scheduler (e.g. Windows, UNIX,Linux)
* short-term scheduler
  * selects which process should be executed next and allocates CPU
  * invoked very frequently(milliseconds)
* medium-term scheduler

<br/>

### 2.3 上下文切换

什么是上下文切换：

> 将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态。
>
>  
>
> 发生上下文切换时，内核会将旧进程的状态保存再PCB中，然后装在经调度后要执行的并已经保存的新进程的上下文。
>
> 上下文切换是额外的时间开销



进程的上下文用PCB来表示。通常执行一个**状态保存**(state save)来保存CPU当前状态(不管是内核模式还是用户模式)，之后再执行一个**状态恢复**重新开始运行

<br/>

# 3 进程操作

## 3.1 进程创建





## 3.4 进程间通信(Interprocess communication IPC)

### 3.4.1 协作

独立：一个进程不能影响其他进程或者被其他进程影响，那么该进程是独立的。

协作：如果系统中一个进程能影响或者被其他进程影响，那么该进程是协作的



协作的优点

* Information sharing
* computation speed-up
* modularity
* convenience



***协作需要进程间通信机制***

IPC provides a Mechanism for processes to **communicate** and to **synchronize** their actions **without sharing the same address space** .



### 3.4.2 IPC分类

**通信类型：**

* **直接通信**

*  **间接通信**

**常用通信机制：**

* 信号(signal)  （中断？）

* 共享存储区(shared memory)

* 管道(pipe) （字节流过程）

* 消息(message)

* 套接字(socket)  （网络进程之间）



<center><img src="/Users/jones/Desktop/miaochenlu.github.io/picture/1569637406268.png" alt="1569637406268" style="zoom: 50%;" /></center>



### 3.4.2 two models of IPC

<center><img src="https://miaochenlu.github.io/picture/1569636805508.png" alt="1569636805508" style="zoom:67%;" /></center>

#### 3.4.2.1 shared memory

需要建立共享内存区域。

Producer-Cunsumer

* unbounded buffer
* bounded buffer



```cpp
#define BUFFER_SIZE 10
typedef struct {
    ...
} item;

item buffer[BUFFER_SIZE];
int in = 0;
int out = 0;

/*
producer
*/
item nextProduced;

while(1) {
    //produce an item in nextProduced;
    while((in+1) % BUFFER_SIZE) == out)
        ;//do nothing
    buffer[in] = nextProduced;
    in = (in + 1) % BUFFER_SIZE;
}
/*
consumer
*/

item nextConsumed;
while(1) {
    while(in == out)
        ;//do nothing   相当于这个buffer是空的,所以do nothing
    nextConsumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
    //consume the item in nextConsumed
}
```

#### 3.4.2.2 Message Passing

If processes P and Q wish to communicate, they need to:

* Establish a communication link between them
* Exchange messages via send/receive



So we propose questions below:

> How are links established?
>
> Can a link be associated with more than two processes?
>
> How many links can there be between every pair of communicating processes?
>
> What is the capacity of a link?
>
> Is the size of a message that the link can accommodate fixed or variable?
>
> Is a link unidirectional or bi-directional?

***How are links established?***

> Implementation of communication link
>
> * Physical:
>
>   * Shared memory
>   * Hardware bus
>
>   * Network
>
> * Logical:
>   * Direct or indirect
>   * Synchronous or asynchronous
>   * Automatic or explicit buffering

***Can a link be associated with more than two processes?***

> * Direct communication（只有两个进程之间建立）
>   * Processes must name each other explicitly:
>     * **send** (*P, message*) – send a message to process P
>     * **receive**(*Q, message*) – receive a message from process Q
>   * Properties of communication link
>     * Links are established automatically
>     * A link is associated with exactly one pair of communicating processes
>     * Between each pair there exists exactly one link
>     * The link may be unidirectional, but is usually bi-directional
>
> * Indirect Communication（多个process共用）
>
>   * Messages are directed and received from mailboxes (also referred to as ports)
>
>     * Each mailbox has a unique id
>     * Processes can communicate only if they share a mailbox
>
>   * Properties of communication link
>
>     * Link established only if processes share a common mailbox
>     * A link may be associated with many processes
>     * Each pair of processes may share several communication links
>     * Link may be unidirectional or bi-directional
>
>   * Operations
>
>     * create a new mailbox (port）
>     * send and receive messages through mailbox
>     * destroy a mailbox
>
>   * Primitives are defined as:
>
>     * **send**(*A, message*) – send a message to mailbox A
>     *  **receive**(*A, message*) – receive a message from mailbox A
>
>   * nMailbox sharing
>
>     l*P**1**, P**2**,* and *P**3* share mailbox A
>
>     l*P**1*, sends; *P**2* and *P**3* receive
>
>     lWho gets the message?
>
>     nSolutions
>
>     lAllow a link to be associated with at most two processes
>
>     lAllow only one process at a time to execute a receive operation
>
>     lAllow the system to select arbitrarily the receiver.  Sender is notified who the receiver was.





Synchronization

> **Blocking**
>
> ​	considered synchronous
>
> * Blocking send: 发送者阻塞直到上一次发送的信息被接受
> * Blocking receive：接收者阻塞直到一个信息可以获得了
>
> **Non-blocking**
>
> ​	considered asynchronous
>
> 效率高，可靠性低
>
> * Non-blocking send: 主动持续发送信息
> * Non-blocking receive：主动不断去做接收的操作
>   * receive A valid message
>   * receive Null message

这四种方式可以组合，其中一种

send blocking + receive blocking ---> **rendezvous**



Buffering

> What is a buffer?
>
> ​	Queue of messages attached to the link.
>
> Implemented in 3 ways
>
> * Zero capacity – no messages are queued on a link.
>    Sender must wait for receiver (rendezvous)
> * Bounded capacity – finite length of *n* messages
>    Sender must wait if link full
> * Unbounded capacity – infinite length 
>    Sender never waits
>
> 

<br/>



Pipe

分类

* Ordinary pipes

cannot be accessed from outside the process that created it.

* Named pipes

can be accessed without a parent-child relationship

<br/>

Socket

A socket is defined as an endpoint for communication

