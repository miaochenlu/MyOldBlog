---
title: "Lazy persistency"
tags: htm
key: page-lp
---

# Lazy Persistency: a High-Performing and Write-Efficient Software Persistency Technique

# 1. overview

NVM->require failure-safety->eagerly flush data out of caches->large overhead

To reduce overheads, we propose Lazy Persitency(LP)

What is LP?

> A software persistency technique
>
> Allow caches to slowly send dirty blocks to the MVMM through natural evictions.



# 2. Introduction

### 2.1 issue

We now have Non-Volatile Main Memory in the system. But achieving persistency asks for failure-safety.

Typically, the system provides a persistency model consisting of 

> * durability ordering
>
> specifies at which point(or order) stores reach the non-volatile domain in the NVMM
>
> * atomic durability
>
> Specifies which group of stores are to be made durable atomically.



### 2.2 persistency models

#### 2.2.1 Eager persistency

persist barrier

>  Force stores to be (eagerly) flushed out of the LLC to NVMM.



Eager persistency is costly

> * the extra instructions added to the program  to define durability ordering increase the instruction count substantially.
> * these instructions are long latency and cause frequent pipeline stalls.
> * By forcing writes to go to NVMM, the NVMM write endurance is reduced
> * It goes against the principle of make the common case fast



#### 2.2.2 Our method

we let caches slowly send written blocks to the NVMM through natural evictions. 

<u>feature</u>

> * there are no additional writes to NVMM
> * no decreased write endurance
> * no performance problems associated with cache line flushes and durable barriers.

<u>Procedure</u>

> A persistency failure, which occurs when a computation’s result has not been made durable, is discovered using software error detection (checksum).
>
> the persistent checksum in memory is inconsistent with the persistent data it protects.
>
> The system recovers by recomputing the inconsistent results.

<br/>

<u>requirements</u>

> 1. define the persistency region granularity, which is the unit of recovery
> 2. a persistency failure detection mechanism needs to be embedded into the code
> 3. The recovery code corresponding to the persistency granularity is needed

<center><img src="https://miaochenlu.github.io/picture/image-20191005205356092.png" alt="image-20191005205356092" style="zoom:80%;" /></center>

<br/>

## 3. background

### A. Intel Persistency Programming Support

compare eager persistency (intel PMEM as example) with lazy persistency

<u>Requirements:</u>

> * Explicitly flush a cache block written to a store instruction in order to force the store to become durable
> * A store fence is needed afterward to avoid stores that follow it(younger stores) from becoming durable before stores that precede it(older stores)

we can see that, a store fence has 2 roles:

1. Acts as memory barrier that ensures older stores are visible to other threads

2. Acts as a durable barrier that ensures older stores(including cache line flush or write back instructions) are durable prior to younger stores.

   > this is supported by Asychronous DRAM Refresh(ADR) platform. It requires the write buffer in the memory controller(MC) to be in the non-volatile domain.
   >
   > When a dirty block is flushed out of the cache hierarchy into the MC, it can be considered durable.



```cpp
//Illustration of a durable transaction with Eager Persistency using PMEM.
for(i = 0; i < N; i++) {
  logC = createLog(&C[i], C[i]);
  logD = createLog(&D[i], D[i]);
 	logLast_i = last_i;
  
  CLFLUSHOPT(logC);
  CLFLUSHOPT(logD);
  CLFLUSHOPT(logLast_i);
  SFENCE;
  
  logStatus = 1;
  CLFLUSHOPT(&logStatus);
  SFENCE;
  
  C[i] = foo(A[i], B[i]);
  D[i] = bar(A[i], B[i]);
  last_i = i;
  CLFLUSHOPT(&C[i]);
  CLFLUSHOPT(&D[i]);
  CLFLUSHOPT(&last_i);
  SFENCE;
  
  logStatus = 0;
  CLFLUSHOPT(&logStatus);
  SFENCE;
}
```

