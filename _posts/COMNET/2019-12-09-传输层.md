---
title: Computer network--传输层
key: page-COMNET6
tags: Computer-network
author: Chenlu Miao
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(34, 139, 87 , .4), rgba(139, 34, 139, .4))'
  background_image:
    src: https://miaochenlu.github.io/picture/IMG_175820190715-004751.png
---

计算机网络课程-传输层总结

<center><img src="https://miaochenlu.github.io/picture/image-20191203144306819.png" alt="image-20191203144306819" style="zoom:50%;" /></center>

<!--more-->

# 1. The Transport Service

* transport layer services
  * To provide efficient, ***reliable,*** and cost effective service to its users, normally processes in the application layer.
  * To make use of the services provided by the network layer.

* the transport entity

  * the hardware and/or software within the transport layer that does the work.

<center><img src="https://miaochenlu.github.io/picture/image-20191126095920516.png" alt="image-20191126095920516" style="zoom:35%;" /></center>



## 1.1 网络层和传输层的区别与联系

> 考虑有两个家庭，一家位于美国东海岸，一家位于美国西海岸，每家有12个孩子。东海岸的孩子们是西海岸家庭孩子们的堂兄弟姐妹。这两个家庭的孩子们喜欢彼此通信，每个人每周要给每个堂兄弟姐妹写一封信，每封信都用单独的信封通过传统的邮政服务发送。因此，每个家庭每周向另一家庭发送144封信。（如果他们有电子邮件的话，这些孩子可以省不少钱！）每个家庭有一个孩子负责收发邮件，西海岸家庭是Ann而东海岸家庭是Bill。每周Ann去她所有的兄弟姐妹那里收集邮件，并将这些邮件交到每天到家门口的邮政运输车上。当信件到达西海岸家庭时，Ann也负责将信件发到她的兄弟姐妹手上，东海岸家庭中Bill也负责类似工作。

我们可以做下面这样的类比:

```
应用层报文　　＝　信封上的字符
进程　　　　　＝　堂兄弟姐妹
主机(端系统)　＝　家庭
运输层协议　　＝　Ann和Bill
网络层协议　　＝　邮政服务
```

在这个例子中，网络层就像邮递员，而运输层就像Ann和Bill。现在我们再来理解上面的这句话:**网络层提供了主机之间的逻辑通信，而传输层为不同主机上的进程之间提供了逻辑通信。**邮政服务知识将信件送到指定的家庭，它不会将信件分发到家庭的具体成员手中。这个分发的工作则是由Ann和Bill提供的。值得注意的是Ann和Bill都是在各自的家里进行工作的，他们没有参与任何中间邮件中心对邮件进行分拣的工作，也没有将邮件从一个邮件中心送到另一个邮件中心。相应的，**运输层协议只工作在端系统中**。在端系统中，运输层协议将来自应用进程的的报文移动到网络边缘(即网络层)，但对有关这些报文在网络层中如何移动却不做任何规定。
由这个例子，我们可以做出如下概括:**网络层提供了不同端系统的数据交付服务，而传输层则将这种不同主机间的交付拓展为了运行在不同端系统上的两个进程之间的交付。**进程到进程之间的数据交付是传输层提供的最基本的服务之一。

<br/>

## 1.2 Hypothetical primitives

<center><img src="https://miaochenlu.github.io/picture/image-20191126100224177.png" alt="image-20191126100224177" style="zoom:30%;" /></center>

<br/>

用segment表示传输实体间发送的消息[一些老协议使用了更加笨拙的名称一一传输协议数据单元。TPDU, Transport Protocol Data Unit]

<center><img src="https://miaochenlu.github.io/picture/image-20191209001317925.png" alt="image-20191209001317925" style="zoom: 30%;" /></center>

***How to use these primitives for an application?***

<center><img src="https://miaochenlu.github.io/picture/image-20191209000910981.png" alt="image-20191209000910981" style="zoom:35%;" /></center>

***Connection establishment and connection release***

<center><img src="https://miaochenlu.github.io/picture/image-20191209002015904.png" alt="image-20191209002015904" style="zoom:35%;" /></center>



<br/>

# 2. Elements of Transport Protocols

## 2.1 传输层协议与数据链路层协议

传输协议在有些方面类似数据链路协议。这两种协议都要处理<u>错误控制、 顺序性和流量控制以及其他一些问题。</u>

然而，两者之间也存在着重大的差别。这些差别是因为这两种协议的运行环境不同而造成的。

{:.info}

在数据链路层，两台路由器通过一条有线或者无线物理信道直接进行通信：而在传输层，该物理信道被整个网络所替代。

<center><img src="https://miaochenlu.github.io/picture/image-20191209002600247.png" alt="image-20191209002600247" style="zoom:50%;" /></center>

* 首先，在点到点链路上，路由器不必指定它要与哪一台路由器进行通话，因为每条出境线路直接通向一台特定的路由器。而在传输层，必须显式地指定接收方的地址。

* 其次，在一条线路上建立一个连接的过程非常简单，另一端总是在那里（除非它崩溃了才不在那里）。两边都不需要做很多事情。如果因发生错误而消息没有被确认，可以再次重发。而在传输层中，初始的连接建立过程非常复杂。 数据链路层和传输层之间的另一个（非常恼人的）差别是，网络存在着潜在的存储容量。当路由器发送一帧到一条链路上后，该帧可能到达对方也可能丢失，但是它不可能先蹦跄一会儿，再躲到远处一个角落中，然后在其他数据包发送出去很久后突然又冒了出来。

  如果网络使用数据报技术，即网络内部的路由是独立进行的，那么就存在一个不可忽略的概率：一个包可能选取了风景优美的路线，一路观光姗姗来迟到达目的地，这将扰乱预期的接收顺序，甚至它的重复数据包都已经到达目的地它还没到呢。网络具有的这种延迟和重复数据包的特性所产生的后果有时是灾难性的，因此要求使用特殊的协议，以便正确地 传输信息。 

* 数据链路层和传输层之间最后一个差别是程度上的差别。这两层都需要缓冲和流量控制，但是，由于传输层上存在着大量并且数量可变的连接，而且由 于连接之间的相互竞争造成连接的可用带宽上下波动，因此需要一种不同于数据链路层使 用的方法。

```python
if (packet.seq see before and time is short (<T))
	discard packet
if (packet.seq see before and time is large (>T))
	accept packet
```

<center><img src="https://miaochenlu.github.io/picture/image-20191126102346530.png" alt="image-20191126102346530" style="zoom: 33%;" /></center>



How to realize

1. Restrict packet lifetime
2. use time-of-day clock to limit sending rate

***forbidden region***

<center><img src="https://miaochenlu.github.io/picture/image-20191126102810011.png" alt="image-20191126102810011" style="zoom: 33%;" /></center>





### error control and flow control

* Error detection:

  * The link layer checksum protects a frame while it crosses a single link.

  * The transport layer checksum protects a segment while it crosses an entire network path. It is an end-to-end check, which is not the same as having a check on every link.

End-to-end argument: transport check is essential for correctness while link layer check is valuable for performance.

# 3. Congestion Control

# 4. The Internet Transport Protocols



# 5. TCP



## 5.8 TCP滑动窗口



## 5.9 TCP timer management

### A. 重传计时器(RTO, Retransmission Timeout)

当 TCP 实体发出一个段时，它同时启动一 个重传计时器。

* 如果在该计时器超时前该段被确认，则计时器被停止。
* 如果在确认到来之前计时器超时，则段被重传（并且该计时器被重新启动）



### B. 如何设置超时间隔

动态算法，根据网络性能的连续测量’情况，不断地调整超时间隔

Jacobson算法

对于每一个 连接，TCP 维护一个变量 SRTT(Smoothed Round-Trip Time，平滑的往返时间)，它代表到达接收方往返时间的当前最佳估计值。

当一个段被发送出去时， TCP 启动一个计时器，该计时器有两个作用:

* 一是看该段被确认需要多长时间
* 二是若确认时间太长，则触发重传动作。

如果在计时器超时前确认返回，则 TCP 测量这次确认所花的时间，比如说 R。然后 它根据下面的公式更新 SRTT: $SRTT ＝\alpha SRTT + (1-\alpha） R$



这里 α 是一个平滑因子，它决定了老的 RTT 值所占的权重。典型情况下 α＝7/8 。这类 公式是指数加权移动平均 CEWMA, Exponentially Weighted Moving Average ），或者丢弃样值中噪声的低通滤波器。



# 5.10 TCP congestion control

<center><img src="https://miaochenlu.github.io/picture/image-20191203131449883.png" alt="image-20191203131449883" style="zoom:40%;" /></center>

当提供给任何网络的负载超过它的处理能力时，拥塞便会产生。当路由器上的队列增长到很大时，网络层检测到拥塞，并试图通过丢弃数据包来管理拥塞。传输层接收到从网络层反馈来的拥塞信息，并减慢它发送到网络的流量速率。



* TCP维持一个<u>***拥塞窗口***</u> (congestion window ），***窗口大小是任何时候发送端可以往网络发送的<u>字节数</u>***。相应的速 则是窗口大小除以连接的***往返时间***。 TCP 根据 AIMD 规则来调整该窗口的大小。

* 一个流量控制窗口，该窗口指出了***接收端可以缓冲的字节数***。

要并发跟踪这两个窗口，可能发送的字节数是两个窗口中较小的那个。 因此，有效窗口是发送端认为的应该大小和接收端认为的应该大小两者中的***较小者***。

> 如果拥塞窗口或流量控制窗口暂时己满，则 TCP 将停止发送数据。
>
> 如果接收端说“发送 64 KB数据”，但发送端知道超过 32KB 的突发将阻塞网络，它就只发送32KB
>
> 如果接收端说“发送 64 KB数据”，发送端知道高达 128 KB的突发通过网络都毫不费力，它会发送要求的全部 64 KB。

<br/>

Congestion Control Algorithm by Van Jacobson (1988) 

* To approximate an **AIMD** congestion window

* To represent congestion signal by packet loss
* To measure packet loss by a retransmission timer 
* To split data into segments (Ack Clock) 
* To use the optimal congestion window 

<center><img src="https://miaochenlu.github.io/picture/image-20191203140815575.png" alt="image-20191203140815575" style="zoom:50%;" /></center>



<br/>

### i. slow start

从初始值1启动，呈指数增长

<center><img src="https://miaochenlu.github.io/picture/image-20191203141645614.png" alt="image-20191203141645614" style="zoom:50%;" /></center>

> 在第一次往返时间，发送端把一个数据包注入网络（并且接收端接收到一个数据包）。在接下来的一个往返时间，发送端发出两个数据包，然后在第三个往返时间发送四个。
>
> 当发送端得到一个确认，他就把拥塞窗口的大小+1，并立即将两个数据包发送到网络中

由于慢速启动导致拥塞窗口按指数增长，网络很快拥塞。为了保持对慢速启动的控制，发送端为每个连接维持一个<u>***slow start threshold***</u>。

> 最初，这个值被设置得任意高。 TCP 以慢速启动方式不断增加拥塞窗口，直到发生超时，或者拥塞窗口超过该阔值。
>
> 每当检测到丢包，比如超时了，slow start threshold就被设置为当前拥塞窗口的一半，整个过程再重新启动。



### ii. Congestion Control

一旦slow start超过了threshold, TCP就切换到线性增加，每个往返时间，拥塞窗口只增加一段

<center><img src="https://miaochenlu.github.io/picture/image-20191203143540623.png" alt="image-20191203143540623" style="zoom:40%;" /></center>

拥塞窗口cwnd和最大段长MSS，一个常见的近似做法

针对cwnd/MSS中可能被确认的每个数据包，将cwnd增加$(MSS \times MSS)/cwnd$



### iii.  TCP Tahoe

<center><img src="https://miaochenlu.github.io/picture/image-20191203144306819.png" alt="image-20191203144306819" style="zoom:50%;" /></center>

- When **cwnd** is below **Threshold**, sender in <u>slow-start</u> phase, window grows <u>exponentially</u>. 
- When **cwnd** is above **Threshold**, sender is in <u>congestion-avoidanc</u>e phase, window grows <u>linearly</u>. 
- When packet loss occurs
  - **cwnd** instead set to 1 MSS; 
  - window then grows exponentially to a **threshold**, then grows linearly
  - Threshold =1/2 of **cwnd** before loss event 

<br/>

### iv. TCP Reno

<center><img src="https://miaochenlu.github.io/picture/image-20191203144359731.png" alt="image-20191203144359731" style="zoom:40%;" /></center>

{:.info}

发送端有一个快速方法来识别它的包己经被丢失。当丢失数据包的后续数据包到达接收端时，它们触发给发送端返回确认。这些确认段携带着相同的确认号，称为重复确认。发送端每次收到重复确认时，很可能另一个包己经到达接收端，而丢失的那个包仍然没有出现。TCP认为三个重复确认意味着这个数据包已经丢失

<center><img src="https://miaochenlu.github.io/picture/image-20191203144834670.png" alt="image-20191203144834670" style="zoom:35%;" /></center>



- When **cwnd** is below **Threshold**, sender in <u>slow-start</u> phase, window grows <u>exponentially</u>. 
- When **cwnd** is above **Threshold**, sender is in <u>congestion-avoidanc</u>e phase, window grows <u>linearly</u>. 
- When a triple duplicate ACK occurs 
  * **cwnd** is cut in half
  * window then grows linearly 
  * Threshold =1/2 of **cwnd** before loss event 
- When timeout occurs 
  - **cwnd** instead set to 1 MSS; 
  - window then grows exponentially to a **threshold**, then grows linearly 
  - Threshold =1/2 of **cwnd** before loss event 



总结如下：

<center><img src="https://miaochenlu.github.io/picture/image-20191203150750984.png" alt="image-20191203150750984" style="zoom:40%;" /></center>



### v. TCP throughput

What’s the average throughput of TCP as a function of window size and RTT?[Ignore slow start]

> Let W be the window size when loss occurs. 
>
> When window is W, throughput is $\frac{W}{RTT }$
>
> Just after loss, window drops to $\frac{W}{2}$, throughput to $\frac{W}{2RTT}$. 
>
> Average throughout: $\frac{0.75 W}{RTT}$



 

### vi. 一道例题

<center><img src="https://miaochenlu.github.io/picture/image-20191203151238340.png" alt="image-20191203151238340" style="zoom:40%;" /></center>

- **(1).** Identify the intervals of time when TCP slow start is operating. 

  看各阶段持续的时间。slow start有两段。答案是9

- **(2).** Identify the intervals of time when TCP congestion avoidance is 

  operating. 

  15

- **(3).** After the 16th transmission round, is segment loss detected by a triple duplicate ACK or by a timeout? 

  triple duplicate ACK 因为cwnd只降了一半

- **(4).** After the 22nd transmission round, is segment loss detected by a triple duplicate ACK or by a timeout? 

  timeout, 因为 cwnd降为1

- **(5).** What is the initial value of **Threshold** at the first transmission round? 

  32 因为32的时候进入了congestion avoidance阶段

- **(6).** What is the value of **Threshold** at the 18th transmission round? 

  21 threshold变成16th cwnd的一半

- **(7).** What is the value of **Threshold** at the 24th transmission round? 

  13 threshold变成16th cwnd的一半

- **(8).** Assuming a packet loss is detected after the 26th round by the receipt of a triple duplicate ACK, what will be the values of the **cwnd** and **Threshold**? 

  cwnd:4	 threshold:4

- **(9).** Suppose **TCP Tahoe** is used (instead of TCP Reno), and assume that triple duplicate ACKs are received at the 16th round. What are the **Threshold** and **cwnd** at the 19th round? 

  cwnd:4 	threshold:21



<br/>

reference:

[1] https://andrewpqc.github.io/2018/07/16/transport-layer-udp-and-tcp/