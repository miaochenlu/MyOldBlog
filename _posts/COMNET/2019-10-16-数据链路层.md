---
title: "Computer network--数据链路层"
tags: Computer-network
key: page-COMNET3

---

# 数据链路层

# 1. 数据链路层的设计问题

数据链路层使用物理层提供的服务在通信信道上发送和接收比特。要实现的功能包括

* 向网络层提供一个定义良好的服务接口
* 处理传输错误
* 调节数据流，确保慢速的接受方不会被快速的发送方淹没

数据包被封装成帧，每个帧包含一个Header,一个Payload field,一个Trailer

<center><img src="https://miaochenlu.github.io/picture/image-20191012225542485.png" alt="image-20191012225542485" style="zoom:50%;" /></center>



## 1.1 提供给网络层的服务

三种服务类型

* 无确认的无连接服务

> 特点
>
> * 事先不用建立物理连接，事后也不用释放逻辑连接
>
> * 源机器向目标机器发送独立的frame,目标机器不对这些frame进行确认
>
> 适合的场合
>
> * 实时通信[数据迟到比数据受损更难忍受]
>
> * 错误率比较低的场合[因为数据链路层可靠性不高，所以物理层reliable要求会高一点，适合有线网络

* 有确认的无连接服务

> 特点
>
> * 不用建立物理连接
> * 发送的每一帧都要单独确认，这样发送方可以知道一个帧是否已经正确到达目的地。如果一个帧在制定时间间隔内还没有到达，则发送方将再次发送该帧
> * 不能保证收到包的顺序和发送顺序一致
>
> 适用场合
>
> * 不可靠的信道：无线系统,WiFi

* 有确认的有连接服务

> 源机器和目标机器在传输任何数据之前要建立一个连接，连接发送每一帧都被编号，数据链路层确保发出的每个帧都会真正被接收方按顺序收到且只收到一次。相当于提供了一个可靠的比特流
>
> 适用场合
>
> * 长距离且不可靠的链路 



## 1.2 framing[成帧]

数据链路层要检测和纠正错误。

数据链路层通常的做法是将比特流拆分成多个离散的帧。

为每个帧计算一个称为校验和的短令牌，放在帧中一起传输。

帧到达目标机器时，重新计算校验和。如果新计算的校验和与传输过来的不同，说明产生了错误。



拆分方法

### 1.2.1 Byte count

Method: to use a field in the header to specify the number of characters in the frame.

<center><img src="https://miaochenlu.github.io/picture/image-20191008100755672.png" alt="image-20191008100755672" style="zoom:35%;" /></center>

problem:

错了一个character count就会全错

<center><img src="https://miaochenlu.github.io/picture/image-20191012232424422.png" alt="image-20191012232424422" style="zoom:50%;" /></center>



### 1.2.2  flag bytes with byte stuffing字节填充的标志字节法

考虑到出错之后到重新同步问题，用一些标志字节(flag byte)作为一个帧开始和结束

<center><img src="https://miaochenlu.github.io/picture/image-20191012233630323.png" alt="image-20191012233630323" style="zoom:50%;" /></center>

如图所示的这种frame的结构

两个连续的flag标志了一帧的结束和下一帧的开始。

problem:

如果标志字节在数据中出现，会干扰到帧的分界

<br/>

所以提出的解决方法是字节填充(byte stuffing)，发送方的数据链路层在数据中偶尔出现的每个标志字节前面插入一个特殊的转义字节(ESC),如果转移字符也出现在数据中，再用一个转义字符填充

<center><img src="https://miaochenlu.github.io/picture/image-20191012234408243.png" alt="image-20191012234408243" style="zoom:35%;" /></center>

### 1.2.3 flag bit with bit stuffing

考虑到字节填充只能使用8bits的字节，这里bit填充可以使帧包含任意大小单元

flag bits 01111110

也要考虑数据中出现flag的问题，所以发送方的数据链路层在数据中每遇到连续的5个1，就添加1个0

接收方看到5个连续的1，后面紧跟1个0，就自动剔除这个0

<center><img src="https://miaochenlu.github.io/picture/image-20191013180557730.png" alt="image-20191013180557730" style="zoom:50%;" /> </center>



### 1.2.4 physical layer encoding violation

物理层有讲过4B/5B的编码，4个比特被映射成5个比特，说明有16种信号不会出现在数据中，可以用来作为flag

## 1.3 Error control

如何保证所有帧最终传递给目标机器的网络层，并且保持正确的顺序

– To provide the sender with some feedback

• Positive acknowledgement (ACK) 收到信号回一个ack
• Negative acknowledgement (NAK) 没收到啊信号回一个nack， 潜在的假设是我知道发送的包以及发送的顺序

– To provide timeout timers

• Resend as necessary

– To number frames
• To distinguish retransmissions from originals

## 1.4 Flow control

发送方发送帧的速度超过了接收方接收的速度，该如何处理

- To introduce flow control to throttle the sender into sending no faster than the receiver can handle the traffic.

- Flow control protocol contains well-defined rules about when a sender may transmit the next frame.

- Twoapproaches
  – **Feedback-based flow control** 由receiver决定发送的速度

  – Rate-based flow control



# 2. Error Detection and Correction

Error Types

> isolated errors单个的错误
>
> burst errors一连串的错误

approaches: 在数据中引入一些<u>冗余</u>来进行error detection和error correction



## 2.1 一些概念

### i.

一帧有

* m个数据位
* r个冗余位。r个校验位是由m个数据位的函数计算得到的

令数据块总长度为n(n=m+r)，我们称其为(n,m)码。

<u>码字</u>(codeword): 一个包含了数据位和校验位的n位单元

码率(code rate): codeword中数据部分占比m/n

### ii.

Hamming distance of 2 codewords

>  两个codeword中不相同的bit的个数

Hamming distance of complete code(all valid codewords)

> The minimum Hamming distance of two valid codewords in the code

<center><img src="https://miaochenlu.github.io/picture/image-20191013185144979.png" alt="image-20191013185144979" style="zoom:33%;" /></center>





To detect d errors, you need d+1 Hamming distance code.

> 因为，d+1的hamming distance,说明两个codeword之间最少有d+1位不相同。所以如果d个错误出现，这个codeword也不会错成一个valid codeword.



To correct d errors, you need 2d+1 Hamming distance code

> 因为,两个codeword之间最少有2d+1个bits不相同，如果有d errors,那么偏离原codeword的hamming distance 为d, 2d+1的距离保证了与这个错误的codeword距离最近的依然是原codeword

## 2.2 Error Correction codes

### 2.2.1 Hamming code for single error

参考以下两篇blog可以有一个基本了解，我结合他们做了一个总结

https://blog.csdn.net/Yonggie/article/details/83186280

https://blog.csdn.net/blue_starry_sky/article/details/53997548

(图片中应该是redundancy)

<table>
  <tr>
    <td><img src="https://miaochenlu.github.io/picture/IMG_5ACFEACB9F7D-1.png" alt="IMG_5ACFEACB9F7D-1" style="zoom: 30%;" /></td>
    <td>
    <img src="https://miaochenlu.github.io/picture/IMG_AA14DF432E13-1.png" alt="IMG_AA14DF432E13-1" style="zoom:40%;" /></td>
  </tr>
</table>



-你知道吗，Hamming codes也可以用来correct burst error呢？

-哦？怎么做呢

-嘿嘿嘿，有一点tricky

-  one codeword per row. k consecutive codewords
- –Transmit the matrix by one column at a time.

这样一行的连串错误，在列看来就是一列可以有一个错误

<img src="https://miaochenlu.github.io/picture/截屏2019-10-16下午6.34.25.png" alt="截屏2019-10-16下午6.34.25" style="zoom:25%;" />





## 2.3 Error Detection codes

相比error correction, error detection代价更小。

error correction引入太多redundancy bit, 不如用error detection，如果检测到error,就retransmission这样代价小。

### 2.3.1 Parity

> Append a parity bit to detect single error.



### 2.3.2 Checksum

### 2.3.3 CRC





