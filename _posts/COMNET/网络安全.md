# 1. Introduction

Network security problems can be divided roughly into four interwined areas: secrecy, authentication, nonrepudiation, and integrity control. 

1. secrecy机密性

> to keep information out of the hands of unauthorized users. 

2. Authentication认证

> to determine whom you are talking to before revealing sensitive information or entering into a business deal. (to authenticate people by recognizing their faces, voices, and handwriting). 
>
> 伪装通信

3. Nonrepudiation不可否认性

> 比如银行转账成功了之后，这个交易就不可否认
>
> 所以要保证完成之后依然有证据能表明这条消息就是你发的

4. Integrity完整性

>  How can you be sure that a message you received was really the one sent and not something that a malicious adversary modified in transit or concocted. 
>
> 消息没有被篡改过



Every layer has something to contribute: 

- Physical layer: Wiretapping can be foiled by enclosing transmission lines in sealed tubes containing argon gas at high pressure. (not always work) 
- Data link layer: Packets on a point-to-point line can be encoded as they leave one machine and decoded as they enter another. (not routed) 
- Network layer: Firewalls can be installed to keep packets in or keep packets out. 
- Transport layer: Entire connections can be encrypted, end to end, that is, process to process. 
- Application layer: Issues such as authentication and nonrepudiation can only be solved at the application layer. 

# 2. Cryptography 

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191217102529286.png" alt="image-20191217102529286" style="zoom:40%;" />

Encryptaion: $E_k(P)=C$

Decryption: $D_k(C)=D_k(E_k(P))=P$



**Kerchoff’s principle:** all algorithms must be public while the key is secret. 



- From the cryptanalyst's point of view, the cryptanalysis problem has three principal variations: 
  * ciphertext only, 唯密文
  *  known plaintext, and 已知明文[我知道你发送的明文和密文，分析出key]
  * chosen plaintext. 选择明文 [我选择发送的明文，然后拿到密文，分析出key]



### Two principles

- Redundancy: All encrypted messages must contain some redundancy, that is, information not needed to understand the message. All messages must contain considerable redundancy so that active intruders cannot send random junk and have it be interpreted as a valid message. 
- Freshness: Some measures must be taken to prevent active intruders from playing back old messages (replay attack). 



### Substitution Ciphers

#### A. Caesar

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191217103306434.png" alt="image-20191217103306434" style="zoom:50%;" />

key: 平移k个字母的k是key

#### B. Monoalphabetic substitution 

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191217103425835.png" alt="image-20191217103425835" style="zoom:50%;" />

key: 26个字母对应表

可以用频率分析破解



### Transposition Ciphers

Transposition ciphers reorder the letters but do not disguise them. In contrast, substitution ciphers preserve the order of the letter but disguise them. 



### One-Time Pads

首先选择一个随机位串作为密钥，然后将明文转变成一个位串（比如使用明文的 ASCII 表示法）。最后，逐位计算这两个串的异或（XOR）值，这样得到的密文是不可能被破解 的。这是因为在数量足够大的密文样本中，每个字母的出现频率是相等的，两字母组合， 三字母组合等等的出现频率也都是如此。

量子密码学





### 两个基本的密码学原则

* redundancy
* freshness



# 2. Symmetric-key algorithms 

对称密钥：加密解密用同一个密钥

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106093337304.png" alt="image-20200106093337304" style="zoom:50%;" />

整个系列的盒叠加起来构成乘积密码（***<u>product cipher</u>***）

* 第一步P1将 12 根输入线做替代操作（即重新排列）。

* 第二步将输入分成 4 个 3 位一组，每一组被独立于其他（S 1 ～ S 4 ）做置换操作。这样的安排展示了一种通过多个小 S 盒来近似达到一个大 S 盒效果的方法。因为小盒子在硬件实现上更现实（例如，一个 8 位 S 盒可以实现一个 256 项的查询表） 而大 S 盒笨重难以制造（例如一个 12 位的 S 盒其中间步骤将至少需要 2 12 =4096 根交叉线）。 虽然这种方法缺乏通用性，但是它仍然非常有用。通过在乘积密码中加入充分大量的处理 步骤，获得的输出可以是输入的极其复杂函数。

## 2.1 DES[Data Encryption Standard]

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106093639276.png" alt="image-20200106093639276" style="zoom:50%;" />

明文按 64 位数据块被加密，生成 64 位密文。

DES 算法以一个 56 位密钥作为参数，它共有 19 个步骤。

* 第一步是一个与密钥无关的替代操作， 它直接作用在 64 位明文上。
* 最后一步是这个替代操作的逆操作。
* 倒数第二步是交换左 32 位和右 32 位。
* 剩下的 16 步在功能上完全相同，但使用了原始密钥的不同函数作为参数。 DES 算法的设计允许使用***同样的密钥来完成解密过程***，这正是任何一个对称密钥算法必须满足的一个特性。在 DES 算法中，解密的步骤只是加密步骤的相反顺序而已。

这些中间步骤的操作如图 8-7(b)所示。每个步骤接受 2 个 32 位输入，并产生两个 32 位输出。左边的输出是右边输入的一份副本。右边的输出是左边输入与一个函数值逐位异 或的结果，该函数的输入参数有两个，分别是右边的输入和当前步骤所用的密钥 K i 。所有 的复杂性都体现在这个函数中。



## 2.2 AES





### Cipher Modes

#### i. Electronic Code Book Mode[ECB]

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191217112557364.png" alt="image-20191217112557364" style="zoom:50%;" />

Leslie can substitute 4th block with 12th block! 

#### ii. Cipher block chaining

#### iii. Cipher Feedback Mode



# 4. Public-key algorithms 

（受密钥控制的）加密算法 E 和解密算法 D 必须满足 3 个要求。

（1）D(E(P)) = P。

（2）从 E 推断出 D 极其困难。

（3）E 不可能被选择明文（chosen plaintext）攻击破解。





### Public-key cryptography requires two keys:

* a public key, used by the entire world for encrypting messages to be sent to that user, and

* a private key, which the user needs for decrypting messages.



### How Alice and Bob establish a secure channel?

* Both Alice's encryption key, $E_A$,  and Bob's encryption key, $E_B$, are assumed to be in a publicly readable file.

* Now Alice takes her first message, P, computes $E_B(P)$ and sends it to Bob. 注意Alice用Bob的公开密钥加密发送信息

* Bob then decrypts it by applying his secret key $D_B(E_B(P))=P$, and sends it

* No one else can read the encrypted message $E_B(P)$, because the encryption system is assumed strong and because it is too difficult to derive $D_B$ from the publicly known $E_B$



## 4.1 RSA



# 5. Digital signatures 

设计一个代替手写签名的方案非常困难。基本上，我们需要的是这样一个系统，其中一方向另一方发送的签名消息必须满足以下条件： 

（1）接收方可以验证发送方所声称的身份。 

（2）发送方以后不能否认该消息的内容。 

（3）接收方不可能自己编造这样的消息。



## 5.1 Symmetric-key signatures

设立一个人人都信任并且又熟知一切的***中心权威机构***，比如 Big Brother（简称 BB）。每个用户选择一个秘密密钥，并且亲手将它送到 BB 的办公室

当 Alice 想要给她的银行业务员 Bob 发送一条签名的明文消息 P 时，她生成 $K_A (B, R_A , t, P)$

* 这里 B 是 Bob 的标识

* $R_A$是 Alice 选择的一个随机数，

* t 是一个时间戳（可用来保证该消息是最新的），

* $K_A (B, R_A , t, P)$表示用她的密钥$K_A$加密之后的消息。

然后，她将该消息发送出去。BB 看到该消息来自 Alice，于是解密该消息，并按图中所示给 Bob 发送一条消息。给 Bob 的消息包含了 Alice 的原始消息的明文 P 和一条经过签名的消息$ K_{BB}(A, t, P)$。Bob 现在执行 Alice 的请求。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106100255475.png" alt="image-20200106100255475" style="zoom:50%;" />

`问题`{:.error}

没有人人都信任的权威机构

## 5.2 Public key signatures

假设$D(E(P))=P$, $E(D(P))=P$

Alice通过传输$E_B(D_A(P))$向Bob发送一条签名的明文消息P

当 Bob 收到这条消息时，他像往常一样利用自己的私钥对消息做替代，从而得到$D_A(P)$, 然后通过使用$E_A$可得到原始的明文。



<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106101036691.png" alt="image-20200106101036691" style="zoom:50%;" />

不妨假设 Alice 后来否认自己曾经给 Bob 发送过消息 P。当这个案子被提到法庭上时，Bob 可以同时出示 P 和 $D_A(P)$。法官很容易验证 Bob 是否真的拥有一条由 $D_A$加密的消息，他只需简单地在消息上应用 $E_A$即可。由于 Bob 并不知道Alice 的私钥是什么，所以，Bob 能获得由 Alice 私钥加密的消息的唯一途径是 Alice 给他发送了这样的消息。

`问题`{:.error}

声称密钥被偷或者改变密钥了怎么办



## 5.3 Message Digests消息摘要

对签名方法的一个批评是，它们通常将两种不相同的功能耦合在一起：***认证和保密***。 通常情况下，认证是必要的，但是***保密性并不一定是必需的***。而且，如果一个系统只提供认证而没有提供保密性的话，往往更加容易申请出口许可。

下面介绍具备认证***不要求加密整条消息***的方案。

> 这个方案以单向散列函数思想为基础，这里的单向散列函数接受一个任意长度的明文作为输入，并且根据此明文计算出一个固定长度的位串。这个散列函数 MD 通常称为消息摘要（message digest）

{:.success}

从一段明文计算出一个消息摘要必须比用公开密钥算法来加密这段明文要***快***得多，所以消息摘要可以被用来加速数字签名算法。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106102436674.png" alt="image-20200106102436674" style="zoom:50%;" />

> Alice 首先计算明文的消息摘要， 然后她针对消息摘要进行签名，并且将签名之后的摘要 与明文本身一起发送给 Bob。如果 Trudy 中途偷换掉 P， 那么当 Bob 计算 MD(P)时就可以发现这一点。



### SHA-1 and SHA-2 Secure hash algorithm

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106103250478.png" alt="image-20200106103250478" style="zoom:50%;" />



### MD5

> 消息被填补到一 个 448 位长（modulo512），然后附加 64 位整数的原始消息长度，使得总输入长度是 512位的倍数。每一轮的计算都用一个正在运行的 128 位缓冲区，完全地混合一个 512 位的输入块。为了便于测量，混合时使用了一个用正弦函数构建的表。使用已知函数的目的是为了避免让人怀疑设计师留下一个巧妙但只有他们可以进入的后门。这个过程一直进行到所有的输入块都已经被用完。128 位缓冲区里的内容就构成了消息摘要。



# 6. Management of public keys 

一个巨大的问题

如果 Alice 和 Bob 彼此之间并不认识， 那么，他们如何获得对方的公钥来开始通信呢？

> 一种很容易想到的解决方案是将公钥放在自己的 Web 站点上，但是这种方案并不能工作，理由如下所述。
>
> 假设 Alice 想要在 Bob 的 Web 站点寻找他的公钥，那么她该怎么办呢？
>
> * 首先，通过 Bob 的 URL，她用浏览器找到 Bob 主页的 DNS 地址，然后向该地址发送一个 GET 请求
> * 不幸的是，Trudy 截获了这个请求，并且将一个伪造的主页发回给 Alice 作为应答，这个伪造的主页可能是 Bob 主页内容的一份副本，只不过其中 Bob 的公钥被替换成 Trudy 的公钥。
> * 当 Alice 现在用$E_T$加密她的第一条消息时，Trudy 解密并阅读该消息，然后用 Bob 的公钥重新进行加密， 再发送给 Bob，而 Bob 根本不知道 Trudy 已经阅读了他所接收到的消息。更糟的是，Trudy 在为 Bob 重新加密消息之前还可以对消息做一些修改。很明显需要有某种机制来确保公钥交换的安全性。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106103528676.png" alt="image-20200106103528676" style="zoom:50%;" />

## 6.1 Certification

需要***认证中心*** （CA，Certification Authority）证明每个公钥属于个人、公司或者其他的组织。

作为一个例子，假设 Bob 希望 Alice 和其他不认识的人能够安全地与他进行通信。他可以带上护照或者驾驶证到 CA 那里，请求认证他的公钥。

然后，CA 给他颁发一个证书，而且 CA 用自己的私钥对证书的 SHA-1 散列值进行签名。然后，Bob 付给 CA 一定的费用，并获得一张包含了

* 证书
* 签过名的散列值 $D_{CA}(MD(P))$

的光盘。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106104351597.png" alt="image-20200106104351597" style="zoom:50%;" />

证书的基本任务是将一个<u>公钥与安全个体（个人、公司等）的名字绑定在一起</u>。证书本身并不是保密的，也没有被保护。

例如，Bob 可能决定将他的新证书放到 Web 站点上， 他的做法是在主页上使用这样一个链接：“点击这里可得到我的公钥证书”。当用户单击该链接之后，就可以得到 Bob 的证书和签名块（即该证书经过签名之后的 SHA-1 散列值）。

当 Trudy 截获了 Alice 请求 Bob 主页的命令时，她该怎么办呢？

> 她可以把她自己的证书和签名块放到伪造的页面上.
>
> 但是当 Alice 读取证书时， 她立即就会发现那不是来自于 Bob，因为 Bob 的名字不在证书中。
>
> Trudy 可以临时修改 Bob 的主页，用她自己的公钥来替换 Bob 的公钥。
>
> 然而，当 Alice 对证书运行 SHA-1 算法时， 她得到的散列值与她将 CA 的公钥（这是众所皆知的）应用在签名块上所得到的散列值不一致。正常应该是$MD(证书)=E_{CA}(D_{CA}(MD(证书)))$
>
> 由于 Trudy 拿不到 CA 的私钥，所以她无法生成一个包含她公钥的签名块，也就无法构造出让 Alice 相信她是 Bob 的 Web 页面。通过这种方式，Alice可以确信她得到的是 Bob 的公钥，而不是 Trudy 或者其他人的公钥。



# 7. Authentication protocols 

## 7.1 Authentication Based on a Shared Secret Key

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106110259841.png" alt="image-20200106110259841" style="zoom:50%;" />

我们假设 Alice 和 Bob 已经共享了一个密钥$K_{AB}$。

这个协议以下面一个在许多其他的认证协议中都出现的原理为基础

> 一方给另一方发送一个随机数，后者将这个随机数做一个特殊的替代，再把结果返回给前者。这样的协议称为质询-回应（challenge-response）协议。

A，B 是 Alice 和 Bob 的标识。

$R_i$是质询，其中下标指明了发起挑战的一方。

$K_i$是密钥，这里 i 代表密钥的所有者。

$K_S$是会话密钥。

> * 在消息 1 中，Alice 以 一种 Bob 能理解的方式将她的标识发送给 Bob。 
>
> * Bob 无法判断这条消息来自 Alice 还是 Trudy，所以他选择发送一个质询，即一个大的 随机数$R_B$ ，并且它以明文方式发给 Alice，如图中的消息 2。
> * 然后 Alice 用她与 Bob 共享的密钥加密此消息，并且在消息 3 中将密文$K_{AB}(R_B)$发送回来。
> * 当 Bob 看到这条消息时，他立即知道这条消息来自于 Alice 
>   * 因为 Trudy 并不知道$K_{AB}$，因此她不可能生成此消息。
>   * 而且，由于$R_B$是在一个很大的空间中被随机选取的（比如说是 一个 128 位的随机数），所以 Trudy 不太可能曾经在以前的会话中看到过 $R_B$和相应的回应。 同样地，她也不可能猜测到任何一个质询随机数所对应的正确回应。
> * 这时候，Bob 已经确信与他通话的是 Alice，但是 Alice 还不能确定对方的身份。Alice 选取了一个随机数$R_A$，并以明文方式送给 Bob， 见图中的消息 4。
> * 当 Bob 以$K_{AB}(R_A)$作为回应的时候，Alice 知道她在跟 Bob 通话。如果他们现在希望建立一个会话密钥，则 Alice 可以选取一个 $K_S$，并且用$K_{AB}$加密之后发送给 Bob 即可。

### Trudy 的reflection attack

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106111639401.png" alt="image-20200106111639401" style="zoom:50%;" />



<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106111040944.png" alt="image-20200106111040944" style="zoom:50%;" />



## 7.2 Establishing a Shared Key: Diffie-Hellman

用在陌生人之间建立共享密钥的协议称为 Diffie-Hellman 密钥交换协议（ DiffieHellman key exchange）（Diffie 和 Hellman,1976）

其工作过程如下所述：

> Alice 和 Bob 必须就两个大数 n 和 g 达成一致
>
> * 这里 n 是一个素数，(n-1)/2 也是一个素数，
> * 并且 g 需要满足一些特殊的条件。
>
> 这些数可以是公开的，所以，他们两人中的任何一个选取 n 和 g，并且通过公开的方式告诉另一个人。
>
> 现在 Alice 选择一个大数 x （比如说 1024 位），并将它保密；类似地，Bob 也秘密地选择一个大数y。
>
> Alice 发起密钥交换协议，她给 Bob 发送一条消息，其中包含了$(n, g, g^x mod \;n)$，Bob 给 Alice 发送一条包含了$(g^y \;mod \;n)$的消息作为应答。现在，Alice 把 Bob 发送给自己的数计算 x 次乘方并且以 n 为模，得到$(g^y mod\;n)^x \;mod\;n$。Bob 也执行类似的计 算，得到$(g^x \;mod\;n)^ y\; mod\; n$。根据模算术定理，双方的计算结果都是 $g^{xy}\; mod\; n$。
>
> 你瞧，就像 变魔术一样，Alice 和 Bob 突然之间共享了一个密钥，即 $g^{xy}\; mod\; n$。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106112609358.png" alt="image-20200106112609358" style="zoom:50%;" />

### 中间人攻击 （man-in-the-middle attack) or 水桶队列攻击（bucket brigade attack）

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106112130423.png" alt="image-20200106112130423" style="zoom:50%;" />

> 现在，每个人都做模算术运算。Alice 计算出密钥为 $g^{xz}\;mod\;n$，Trudy 也一样（针对所 有发送给 Alice 的消息）。
>
> Bob 计算出 $g^{yz}\;mod\;n$，Trudy 也做同样的计算（针对所有发送给 Bob 的消息）。
>
> Alice 认为她在跟 Bob 通话，所以她建立一个会话密钥（实际上，与 Trudy 共享此会话密钥）。Bob 也如此。
>
> Alice 在此加密会话上发送的所有消息都被 Trudy 捕获到， 并存储下来，如果愿意的话做适当修改，然后（可选地）传递给 Bob。在另一个方向上也类似。
>
> Trudy 看到了所有的秘密，而且可以随意地改动所有的消息，而 Alice 和 Bob 都错误地认为自己与对方有一条安全的信道。



## 7.3 Authentication Using a Key Distribution Center

与陌生人建立共享密钥差不多可以工作了，但是并不完全解决问题。另一方面，有可能从一开始就不值得这么做（酸葡萄攻击）。

> 若通过这种方式与 n 个人进行通话，那么你将需要 n 个密钥。对于普通人来说，密钥管理将变成一份实实在在的负担，尤其当每个密钥都必须被存储在一个单独的塑料芯片卡上的时候。

不同的方法是:

引入一个可信的密钥分发中心（KDC）。在这种模型中，每个用户与 KDC 共享一个密钥。现在认证和会话密钥管理都通过 KDC 来完成。下图显示了目前已知的最简单的 KDC 认证协议，它涉及两方和一个可信的 KDC。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200106113111415.png" alt="image-20200106113111415" style="zoom:50%;" />

> Alice 选取一个会话密钥$K_S$ ，并且告诉 KDC 她希望利用$K_S$与 Bob 进行通话。这条消息用 Alice 与 KDC 之间的共享密钥 $K_A$（只有 Alice 和 KDC 才知道）加密。
>
> KDC 解密此消息，并提取出 Bob 的标识和会话密钥。然后它构造一条新的消息，其中包含了 Alice 的标识和会话密钥，并且它将这条消息发送给 Bob。这次用 Bob 与 KDC 之间的共享密钥$K_B$加密。
>
> 当 Bob 解密出该消息时，他就知道 Alice 想与他通话， 并且她希望使用 $K_S$ 作为会话密钥。

#### Replay Attack

> Trudy 需要一些钱，所以她想出一些自己可以帮助 Alice 处理的合法业务，向 Alice 提出优厚的条件，最后得到了这份工作。在完成了工作以后，Trudy 礼貌地请求 Alice 通过银行转账来支付费用。然后 Alice 与她的银行服务 员 Bob 建立一个会话密钥。之后她给 Bob 发送一条消息，请求将一笔钱转到 Trudy 的账户中。
>
> 同时，Trudy 又故伎重演，她在网络上窃听流量，并且将图中的消息 2 和随后的转账请求消息复制下来。稍后，她又把这两条消息重新发送给 Bob。Bob 收到这两条重放 消息后，他会这样想：Alice 一定又雇佣了 Trudy，很显然 Trudy 干得不错。于是，Bob 又 一次将同样数额的一笔钱从 Alice 的账户转到 Trudy 的账户上。经过了 50 次这样的消息重放以后，Bob 走出办公室并找到 Trudy，表示愿意为她提供一大笔贷款，以便 Trudy 能够拓展她那看起来显然很成功的业务。

Authentication Using Kerberos

Authentication Using Public-Key Cryptography

# 8. Email security 

# 9. Communicationsecurity 