# 1. DNS--域名系统

{:.info}

DNS：将主机名映射成IP地址

应用程序调用一个名为resolver的库程序，并将名字作为参数传递给此程序



## 1.1 DNS命名空间

Internet 被划分为超过 250 个顶级域名[top-level domains]，其中每个域涵盖了许多主机。这些域又被进一步划分成子域，这些子域可被再次划分，依此类推。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191210095855878.png" alt="image-20191210095855878" style="zoom:40%;" />

## 1.2 Resource records

A resource record is a five-tuple

{:.success}

Domain_name, Time_to_live, Class, Type, Value

* Domain_name[域名]

指出这条记录属于哪个域

* Time_to_live[生存期]

指明这条记录的稳定程序。比如，极为稳定的信息会被分配一个很大的值86400，而非常不稳定的信息会被分配一个很小的值

* class[类别]

对于Internet信息，这个字段总是`IN`

* Type[类型]

指出这是什么类型的记录

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191217094323474.png" alt="image-20191217094323474" style="zoom:40%;" />

* Value

该字段的值可以是一个数字、一个域名或者一个 ASCII 字符串，其语义取决于记录的类型

<br/>

来看一个例子

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191217095418085.png" alt="image-20191217095418085" style="zoom:50%;" />

* 第一个非注释行给出了该域的一些基本信息，我们以后将不再关心这些信息。 

* 接下来的两个表项给出了第一个和第二个投递电子邮件给 person@cs.vu.nl 的地点。
  * 首先尝试的是 zephyr （一台特定的机器〉
  * 如果给它发送失败了，则下一个应该尝试给 top 发送
* 下一行标识了该域的名字服务器为star。

* 接下来是一个空白行，加入空白行的目的是为了增加可读性
* 再下面的几行给出了 star、 zephyr 和 top 的IP地址
* 紧跟这些行后面的是别名 www.cs.vu.nl，因此可以使用这个地址而无须指派一台特殊的机器。创建这个别名的好处是允许 cs.vu.nl 改变它的 WWW 服务器， 无须使得人们原来所使用的地址失效
* 类似地， ftp.cs.vu.nl 也是一个别名。

* 有关机器 flits 的信息部分列出了两个 IP 地址和处理发送至 flits.cs.vu.nl 电子邮件的三种选择。首先选择的是 flits 本身，但是如果它失效， zephyr 和 top 是第二个和第三个 选择。

* 接下来的 3 行包含了一台计算机的典型表项，在这个例子中是 rowboat.cs.vu.nl 。它提供的信息包括 IP 地址、主要邮件存放处和次要邮件存放处。 
* 然后是一个针对一台计算机的表项，这台计算机自己不能接收邮件：
* 紧随其后的一个表项可能是指一台连接到 Internet的打印机。

## 1.3 Name servers

查询一个名字和找出其对应地址的过程称为***域名解析***[name resolution ]。

### A. authoritative record

当解析器需要查询一个域名，它就把该查询传递给一个本地域名服务器。如果需要寻找的域恰好落在该域名服务器管辖下，比如 top.cs.vu.nl 在 cs.vu.nl 的管辖下，则该域名服务器就返回***权威资源记录***。一个权威记录[ authoritative record]由管理该记录的权威部门提供，因此总是正确的。

### B. cached record

权威记录的权威性是相对缓存记录[cached record ]而言的，缓存的记录有可能过时。

### C. root name servers

There are 13 root DNS servers, unimaginatively called a-root-servers.net through m.root-servers.net. They have information about each top-level domain.



### D. name resolution example

如果被查询域在远端，比如 flits.cs.vu.nl 要找到华盛顿大学robot.cs.washington.edu 的 IP 地址，会发生什么？如果本地没有关于相关域的缓存信息，那么域名服务器启动一次远程查询。

1. 显示查询报文被发送到本地域名服务器[第一步]。查询中包含了被查询的域名、类型[A]和类[IN]。
2. 通过请求其中之一的根域名服务器来启动域名层次结构顶部的查询。这些域名服务器包含每个顶级域名的有关信息。为了与一个根服务器取得联系，每个域名服务器必须有一个或多个根域名服务器的信息。这个信息通常放在一个系统配置文件中，在 DNS 服务器启动时把该文件加载到 DNS 缓存。这个文件很简单，只是列出了关于根服务器的 NS[name server] 记录和相应的 A[IPv4] 记录。
3. 根域名服务器不可能知道在 uw 的一台机器的地址，可能还不知道 uw 的域名服务器。 但是，它必须知道 edu 域的域名服务器，因为 cs.washington.edu 属于 edu 域管辖下。在第 3 步，它返回查询的答案，其中包括了名字和 IP 地址。
4. 然后本地域名服务器继续尽职地执行任务。它将整个查询发给 edu 域名服务器[a.edu­-servers.net]。该域名服务器返回UW的域名服务器。上述过程显示在图中的第 4 步和第 5步。
5. 本地域名服务器把查询发送给UW的域名服务器[第 6 步]。 如果被查询的域名是英语系，则马上能找到答案，因为 uw 域包括了英语系。但是，计算 机科学系选择运行自己的域名服务器，因此该查询返回的是 uw 计算机科学系的域名服务 器和 IP 地址[第 7 步]。
6. 最后，本地域名服务器查询UW计算机科学系的域名服务器[第 8 步]。这台服务器是 cs.washington.edu 的***权威机构***，所以它必定有答案。它返回最终的答案[第 9 步]，即作为响应 flits.cs.vu.nl [第10步]转发的本地域名服务器。至此，查询的域名得到了解析。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191217100055190.png" alt="image-20191217100055190" style="zoom:50%;" />

<img src="/Users/jones/Desktop/miaochenlu.github.io/assets/images/image-20200102104749552.png" alt="image-20200102104749552" style="zoom:50%;" />

> **根域名服务器**是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。在因特网上共有13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从a 一直到 m（前13 个字母）。
>
> **顶级域名服务器**负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。 
>
> **权限域名服务器**是负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。 
>
> **本地域名服务器**对域名系统非常重要。当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。每一个因特网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器。 

### E. Query machanism

#### i. recursive query

> 当主机 flits.cs.vu.nl 将查询发送给本地域名服务器后，该域名服务器就代替该主机处理域名解析工作，直到它返回所需的答案。这里的答案必须是完整的，它不能返回部分答案。这个机制称为递归查询[recursive query ]。
>
> some detailed explanation from stackExchange
>
> > If there are 2 DNS servers, DNS-A is the authority for domain-a, and DNS-B is the authority for domain-b
> >
> > Someone sends a DNS query to DNS-A for a lookup of domain-b. DNS-A would then be recursing by sending a request to DNS-B in order to lookup domain-b. Essentially, a recursive query is when a DNS server, on behalf of the client that sent the query, chase the trail of DNS in order to fulfill the request.

#### ii. iterative query

> 根域名服务器[和每个后续的域名服务器]并不是递归继续查询本地域名服务器。它只是返回一个部分答案，并移动到下一个查询操作。本地域名服务器负责继续解析，具体做法是发出进一步的查询报文。这个机制称为迭代查询[iterative query], 又称作重指引,返回的是最佳的查询点或者主机地址





#### iii. DNS Cache

> 所有的查询答案，包括所有的部分答案都会被缓存。
>
> 这样， 如果另一台 cs.vu.nl 主机需要查询 robot.cs.washington.edu，那么答案早就有了。
>
> 更妙的是， 如果在同一个域中的一台不同主机需要查询另一台主机，比如 galah.cs.washington.edu，那么此次查询可直接发送到权威的域名服务器。类似地，针对 washington.edu 其他域的查询 也可以从 washington.edu 域名服务器直接开始。这种使用缓存答案的做法可大大降低一次查询的步骤，并能提高查询性能。

`问题`{:.error}

> 高速缓存的答案不具权威性，因为在 cs.washington.edu 所做的信息变化将不会传播到世界上所有可能知道它的缓存。
>
> 出于这个原因，缓存的表项不应该生存得太长。这 就是为什么在每条资源记录中要包含 Time to live 宇段的原因。它告诉远程域名服务器可缓存本记录多长时间。如果某台机器己经多年使用相同的 IP 地址，将它的信息缓存 1 天可 能是安全的。而对于波动比较大的信息，几秒钟或一分钟后清除掉记录的做法或许更安全。



#### iv. UDP

> 域名系统采用的是 UDP
>
>  DNS消息通过 UDP 数据包发送，格式非常简单，只有查询和响应。域名服务器可用此数据包继续进行解析操作。



 Non-Recursive Queries are EnabledDNS cache窥探是一个获取已经被DNS服务器解析的请求的过程。如果我们想检查hostname是否被本地DNS网络解析，这将很有用。这意味着本地网络中的节点近期使用那台DNS服务器请求过hostname。从而可以窥探在某一个时间user访问了哪个页面。 
如果我莫使用一个非递归查询来解析一个已经解析的域名，那么DNS服务器对于cache窥探很敏感。为了检查DNS服务器是否对于DNS窥探敏感，我们可以尝试用非递归请求来查找一个域名：如果DNS服务器不知道那么它也不请求其他DNS服务器。 



nslookup

# 2. 电子邮件

## 2.1 体系结构和服务

<img src="/Users/jones/Desktop/miaochenlu.github.io/assets/images/image-20200102094320059.png" alt="image-20200102094320059" style="zoom:50%;" />

上图是一个电子邮件系统的体系结构。他包括两类子系统：

* user agent

> user agent是一个程序。用户通过它和电子邮件系统交互。用户代理提供了一个图形界面，有时是一个基于文本和基于命令的接口。它包括了撰写邮件、回复邮件、显示入境邮件信息的手段，同时还提供了如何过滤、搜索和删除邮件的组织方式。把新邮件发送给邮件系统，并通过它传递的行为称为***邮件提交***（ mail submission ）。

* message transfer agent

> 邮件传输代理通常是系统进程。它们运行在邮件服务器机器的后台，并始终保持运行状态。它们的工作是通过系统自动将电子邮件从发送端移动到收件人，采用的协议是简单 邮件传输协议（ SMTP, Simple Mail Transfer Protocol ）。

{warning:.}

电子邮件系统的一个关键思想是将信封（ envelope ）与邮件内容区分开来

信封将消息封装成邮件，它包含了传输消息所需要的所有信息，例如目标地址、优先级和安全等级。消息传输代理根据信封来进行路由，就好像邮局的做法一样。

信封内的消息由两部分组成：邮件头（header）和邮件体（ body）。邮件头包含用户代理所需的控制信息。邮件体则完全提供给收件人，代理和邮件传输代理都不在意邮件体包含了什么信息。

<img src="/Users/jones/Desktop/miaochenlu.github.io/assets/images/image-20200102095124155.png" alt="image-20200102095124155" style="zoom:50%;" />



## 2.2 user agent

用户代理是一个程序（有时也称为***电子邮件阅读器***），它接收各种各样命令，从接收和 回复邮件到操纵邮箱的命令

<img src="/Users/jones/Desktop/miaochenlu.github.io/assets/images/image-20200102095840850.png" alt="image-20200102095840850" style="zoom:50%;" />

## 2.3 邮件格式Message Formats

* RFC 5322 – The Internet Message format

> 邮件由一个基本的信封（作为SMTP的一部分由RFC 5321 描述)、数个头字段、一个空行和邮件体组成。头的每个字段（逻辑上）由一行 ASCII 文本组成，其中包括域名、一 个冒号，对于大多数头的字段来说还包括一个值

* MIME (Multipurpose Internet Mail Extensions)

> MIME的基本思想是继续使用RFC 822 格式（在RFC 5322 之前 MIME伍就己经被提出来了），但在邮件体中增加了结构性，并且为传送非 ASCII 码的邮件定义了编码规则

base64 encoding

每24位编成一组，一组被分成4个6bits的单元。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102111814441.png" alt="image-20200102111814441" style="zoom:40%;" />

## 2.4 邮件传送

<img src="/Users/jones/Desktop/miaochenlu.github.io/assets/images/image-20200102105017535.png" alt="image-20200102105017535" style="zoom:50%;" />

发送邮件的协议: SMTP

> 这是一个简单的***ASCII协议***：[因此要用base64将二进制数据转化为ASCII码]
>
> 端口号:***25***
>
> ***TCP连接***
>
> 

读取邮件的协议：POP3 和 IMAP

> 1. 发件人调用 PC 机中的用户代理撰写和编辑要发送的邮件。
> 2. 发件人的用户代理把邮件用 SMTP 协议发给发送方邮件服务器，
> 3.  SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。
> 4.  发送方邮件服务器的 SMTP 客户与接收方邮件服务器的 SMTP 服务器建立 TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。
> 5.  运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。 
> 6.  收件人在打算收信时，就运行 PC 机中的用户代理，使用 POP3（或 IMAP）协议读取发送给自己的邮件。  

也可以基于web

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102112054589.png" alt="image-20200102112054589" style="zoom:50%;" />

# 3. World wide web

请求-响应 协议： HTTP

如果每次显示的是相同的一个文档，则称该网页为静态页面（ static page ）。

相反，如果每次显示的是程序按需产生的内容，或者页面本身包含了一个程序，则称该网页为动态页面[dynamic page]

## 3.1 客户端browser

当 Web 最初被建立时，为 了让一个页面指向另一个 Web 页面，很显然需要某些机制来命名和定位页面。尤其是，在显示一个被选中的页面之前，首先必须回答 3 个问题：

1. 这个页面叫什么？

2. 这个页面在哪里？

3. 如何访问这个页面？



### URL

每个页面被分配一个统一资源定位符（URL, Uniform Resource Locator），用来有效地充当该页面在全球范围内的名字。 

URL 包括 3 个部分：

* 协议[scheme/protocol]
* 页面所在机器的DNS 名字[DNS name]
* 唯一指向特定页面的路径[path name]\(通常是读取的一个文件或者运行在机器上的一个程序)。 一般情况下 ， 路径是一个模仿文件目录结构的层次名字。然而，如何解释路径是 服务器的事，而且路径可能反映了实际的目录结构，也可能不反映实际的目录结构。

> 比如：http : //www.cs.washington.edu/index.html
>
> protocol(http), DNS(www.cs.washington.edu), path name(index.html)

用户点击这个超链接，发生

> * 浏览器确定 URL（通过观察选中的什么）。
>
> * 浏览器请求 DNS 查询服务器 www.cs.washington.edu 的 IP 地址。
> * DNS 返回 128.208.3.88 。
> * 浏览器与 128.208.3.88 机器的 80 端口建立一个 TCP 连接，80 端口是 HTTP协议 的知名端口。
>
> * 浏览器发送 HTTP 报文，请求/index.html 页面。
>
> * www.cs.washington.edu 服务器发回页面作为 HTTP 响应，例如发送文件/index.html 。
>
> * 如果该页面包括需要显示的 URL，那么浏览器经过同样的处理过程获取其他 URL。 在这种情况下， URL 包括多个取自 www.cs.washington.edu 的内嵌图像、一个取自 youtube.com 的内嵌视频和一个取自 google-analytics.com 的脚本。
>
> * 浏览器显示页面/index.html
>
> * 如果短期内没有向同一个服务器发出其他请求，那么释放 TCP 连接。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102114321504.png" alt="image-20200102114321504" style="zoom:50%;" />



### MIME

Browsers can handle many additional types besides HTML pages, like image, video

Browser can use MIME types.

#### How to handle other MIME types:

* Plug-ins: A plug-in is a code module that the browser fetches from a special directory on the disk and installs as an extension to itself.

* Helper applications: A help application is a complete program, running as a separate process.

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102114534063.png" alt="image-20200102114534063" style="zoom:50%;" />

## 3.2 Server

服务器的一种简单工作方式

> 1. 接受来自客户端（浏览器）的 TCP 连接。 
> 2. 获取页面的路径，即被请求文件的名字。
> 3. 获取文件（从磁盘上）。 
> 4. 将文件内容发送给客户。 
> 5. 释放该 TCP 连接。

改进：

1. 在内存中维护一个缓存，其中保存着 n 个最近使用过的文件或者数千兆量的内容。服务器在从磁盘读取文件之前，首先检查缓存。如果缓存中有该文件，则直接从内存中取出文件，从而消除了访问磁盘的时间。
2. 为了解决一次只能服务一个请求的问题，一种策略是将服务器设计成多线程模式 ( multithreaded）。在其中一种设计方案中，服务器由一个前端模块（front-end module ）和 k 个处理模块（ processing module ）组成。

> 前端模块接受所有入境请求： k+1个线程全部属于同一个进程，这样所有处理模块都可以访问当前进程地址空间中的缓存。
>
> * 当一个请求到达时，前端模块接受它，并为其创建一条描述该请求的简短记录，然后将该记录递交给其中一个处理模块。
>   * 处理模块首先检查缓存，查看其中是否有所需的文件。如果缓存中有该文件，则处理模块修改记录，在记录中增加一个指向该文件的指针：
>   * 如果缓存中没有该文件，则处理模块执行一次磁盘操作将该文件读入缓存（可能要丢弃其他一些缓存的文件，以便腾出空间）。 从磁盘上读取文件后，将该文件放入缓存，同时把它发送给客户。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102114808842.png" alt="image-20200102114808842" style="zoom:50%;" />

### cookies

当客户请求一个 Web 页面时，服务器除了提供所请求的页面以外，还以 Cookie 的形式提供了一些附加的信息。服务器将它与浏览器关联。这种关联与用户关联不一样，但它非常接近而且比 IP 地址更有用。浏览器把服务器所提供的 Cookie 通常存储在***客户机***磁盘 Cookie 目录下一段时间，这样在整个浏览器调用期间一直坚持 Cookie，除非用户禁用 Cookie. Cookie 只是字符串，而不是可执行程序

 A cookie may contain up to 5 fields 

* **Domain**: where the cookie came from 

- **Path**: which parts of the server’s file tree may use it 
- **Content**: *name=value* lists 
- **Expires**: when the cookie expires. 
- **Secure**: can be set to indicate that the browser may only return the cookie to a server using a secure transport. 

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102115347076.png" alt="image-20200102115347076" style="zoom:50%;" />

在浏览器向某个 Web 站点发出一个页面请求之前，浏览器检查它的 Cookie 目录，确定这个请求前往的目标域是 否在当前客户端放置了 Cookie 。如果存在相应的 Cookie，则该域放置的所有 Cookie 都被 包含到请求消息中。服务器得到了这些 Cookie 以后，就可以按它所期望的方式来解释它们。

> 例子如下：
>
> 第一个 Cookie 由 toms-casino.com设置，并且被用来标识一个顾客。当该顾客下个星期登录进去花掉了一些钱时，浏览器将 Cookie 发送过去，因此服务器就知道他是谁了。有了顾客的 ID ，服务器就可以在数据库中查找该顾客的消费记录，并利用这些记录信息来创建一个合适的 Web 页面显示给该顾客。 如果己知该顾客爱好赌博，则为其显示的页面可能由扑克游戏、今日赛马比赛名单，或老 虎机组成。

### Static Web Pages: HTML

### Dynamic Web Pages:

#### 1. Server-side dynamic web page generation

***CGI: 公共网关接口（ CGI, Common Gateway Interface)***

> CGI 提供了一个接口，允许 Web 服务器与后端程序及脚本通信：这些后端程序和脚本接受输入信息（例如，来自表单），并生成 HTML 页面作为响应。



按照惯例，通过 CGI 调用的程序常驻在一个称为cgi-bin的目录下，该目录在 URL 中 可以看到。服务器将一个请求映射到这个目录下一个程序名，并且以一个单独的进程执行该程序。它把与请求一起发送过来的任何数据作为程序的输入，而程序的输出则提供了一 个返回给浏览器的网页。

一些语言

> PHP: Hypertext Preprocessor
>
> JSP: Java Server Pages
>
> ASP.NET: Active Server Page

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102120429888.png" alt="image-20200102120429888" style="zoom:50%;" />

`缺点`{error:.}

Can't respond to mouse movements or interact with users directly





#### 2. Client-side dynamic web page generation

JavaScript

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102120529269.png" alt="image-20200102120529269" style="zoom:50%;" />

> PHP 和 JavaScript 看上去很相似，它们都是嵌入在 HTML 文件中的代码，但它们的处理方式完全不同。当用户单击了 submit 按钮后，浏览器将表单中的信息收集到一个长字符串中，然后将它发送给服务器请求一个 PHP 页面。服务器加载该 PHP 文件，并且执行内嵌的 PHP 脚本，由此产生一个新的 HTML页面。然后该页面被送回给浏览器以便显示出来。浏览器不能确定这是由一个程序生成的。
>
> 在JavaScript 示例中，当用户点击 submit 按钮，浏览器就解释该页面中包含的一个 JavaScript 函数。所有的工作都在本地完成，即在浏览器内部完成。这时没有与服务器取得任何联系。因此，结果几乎在瞬间就显示出来，而用PHP生成的 HTML 在到达客户端之前可能有几秒钟的延迟。
>





## 3.3 HTTP

HTTP 是一个简单的请求-响应协议，它通常运行在 TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。

### A. Connections

#### HTTP 1.0 with multiple connections

* Establish a TCP connection

* Send a request

* Get a single response

* Terminate the TCP connection

#### HTTP 1.1 with persistent connections

* Establish a TCP connection

* Looping for sending a request and getting a single response

* Terminate the TCP connection

HTTP 1.1 with ***persistent connections*** and ***pipeline requests***.

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102135101202.png" alt="image-20200102135101202" style="zoom:50%;" />

RTT: round trip time; is the time it takes for a small packet to travel from client to server and then back to the client.

The RTT includes 

* packet propagation delays,

* packet queuing delays in intermediate routers and switches

* packet processing delays.

一道题目

> Suppose within your Web browser you click on a link to obtain a Web page. Suppose that the IP address for the associated URL is not cached in your local host, so that a DNS lookup is necessary to obtain the IP address. Suppose that ***n DNS servers are visited*** before your host receives the IP address from DNS; the successive visits incur an RTT of RTT1 , ..., RTTn. Further suppose that the Web page associated with the link contains exactly one object, a small amount of HTML text. Let ***RTT0 denote the RTT between the local host and the server containing the object***. Assuming zero transmission time of the object, how much time elapses from when the client clicks on the link until the client receives the object? 
>
> Suppose the HTML file indexes three very small objects on the same server. Neglecting transmission times, how much time elapses with
>
> 1. Multiple HTTP connections and sequential requests
>
> $$RTT_1+RTT_2+\cdots + RTT_n$$  DNS
>
> +$$4\times (RTT_0+RTT_0)$$ 				**first RTT0: TCP建立连接 第二个RTT0，传递数据，piggyback ack信号**
>
> 2. persistent HTTP connection and sequential requests
>
> $$RTT_1+RTT_2+\cdots + RTT_n$$    **DNS**
>
> +$$RTT_0$$ **只需要建立一次TCP连接**
>
> $$+4\times RTT_0$$     **传递数据，piggyback ack信号**
>
> 3. persistent HTTP connection and pipelined requests
>
> $$RTT_1+RTT_2+\cdots + RTT_n$$    **DNS**
>
> +$$RTT_0$$ **只需要建立一次TCP连接**
>
> $$+RTT_0$$     **pipeline数据**

### B. Methods

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102140856484.png" alt="image-20200102140856484" style="zoom:40%;" />

i. GET

>`GET filename HTTP/1.1`
>
>其中 filename 是预取的页面名字， 1.1 是协议版本号。

ii. HEAD

>HEAD 方法只请求消息头，不需要真正的页面。这个方法可以收集建索引所需要的信息，或者只是测试一下 URL 的有效性。

iii. POST

> The POST method is used when forms are submitted. Both it and GET are also used for SOAP Web services.
>
> * It uploads data to the server (i.e., the contents of the form or RPC parameters).
>
> * The server then does something with the data that depends on the URL, conceptually appending the data to the object.
>
> * Finally, the method returns a page indicating the result.

iii. PUT

> The PUT method is the reverse of GET: instead of reading the page, it writes the page. This method makes it possible to build a collection of Web pages on a remote server.

iv. DELETE

> Delete removes the page, or at least it indicates that the Web server has agreed to remove the page. As with PUT, authentication and permission play a major role here.

v. TRACE

> The TRACE method is for debugging. It instructs the server to send back the request.

vi. CONNECT

> The CONNECT method lets a user make a connection to a Web server through an intermediate device, such as a Web cache.

vii. OPTIONS

> The OPTIONS method provides a way for the client to query the server for a page and obtain the methods and headers that can be used with that page 

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102141529451.png" alt="image-20200102141529451" style="zoom:50%;" />

4××码意味着由于客户错误而导致请求失败，比如无效请求或者不存在的页面。

5 ××错误码意味着服务器自身出现内部问题，有可能是服务器代码中有错误，也可能是临时负载过重。



#### caching

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102141820421.png" alt="image-20200102141820421" style="zoom:50%;" />

How to determine that a previously cached copy of a page is the same as the page would be if it was fetched again?

> * The first strategy is page validation(step 2). The cache is consulted, and if it has a copy of a page for the requested URL that is known to be fresh (i.e., still valid), there is no need to fetch it anew from the server.
>
>   并非所有的网页都有个方便的 Expires 头来告诉你何时必须重新获取网页,需要有方法来预测过期时间
>
> * The second strategy is to ask the server if the cached copy is still valid. This request is a conditional GET (step 3). 如果服务器知道缓存的副本仍然是有效的，它可以发送一个简短的答复说是的（第 4a 步)。否则，它必须发送完整的响 应消息（第 4b 步)。
>
> 