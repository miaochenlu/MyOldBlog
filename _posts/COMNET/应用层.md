# 1. DNS--域名系统

{:.info}

DNS：将主机名映射成IP地址

应用程序调用一个名为resolver的库程序，并将名字作为参数传递给此程序



## 1.1 DNS命名空间

Internet 被划分为超过 250 个顶级域名[top-level domains]，其中每个域涵盖了许多主机。这些域又被进一步划分成子域，这些子域可被再次划分，依此类推。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191210095855878.png" alt="image-20191210095855878" style="zoom:40%;" />

## 1.2 Resource records

A resource record is a five-tuple

{:.success}

Domain_name, Time_to_live, Class, Type, Value

* Domain_name[域名]

指出这条记录属于哪个域

* Time_to_live[生存期]

指明这条记录的稳定程序。比如，极为稳定的信息会被分配一个很大的值86400，而非常不稳定的信息会被分配一个很小的值

* class[类别]

对于Internet信息，这个字段总是`IN`

* Type[类型]

指出这是什么类型的记录

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191217094323474.png" alt="image-20191217094323474" style="zoom:40%;" />

* Value

该字段的值可以是一个数字、一个域名或者一个 ASCII 字符串，其语义取决于记录的类型

<br/>

来看一个例子

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191217095418085.png" alt="image-20191217095418085" style="zoom:50%;" />

* 第一个非注释行给出了该域的一些基本信息，我们以后将不再关心这些信息。 

* 接下来的两个表项给出了第一个和第二个投递电子邮件给 person@cs.vu.nl 的地点。
  * 首先尝试的是 zephyr （一台特定的机器〉
  * 如果给它发送失败了，则下一个应该尝试给 top 发送
* 下一行标识了该域的名字服务器为star。

* 接下来是一个空白行，加入空白行的目的是为了增加可读性
* 再下面的几行给出了 star、 zephyr 和 top 的IP地址
* 紧跟这些行后面的是别名 www.cs.vu.nl，因此可以使用这个地址而无须指派一台特殊的机器。创建这个别名的好处是允许 cs.vu.nl 改变它的 WWW 服务器， 无须使得人们原来所使用的地址失效
* 类似地， ftp.cs.vu.nl 也是一个别名。

* 有关机器 flits 的信息部分列出了两个 IP 地址和处理发送至 flits.cs.vu.nl 电子邮件的三种选择。首先选择的是 flits 本身，但是如果它失效， zephyr 和 top 是第二个和第三个 选择。

* 接下来的 3 行包含了一台计算机的典型表项，在这个例子中是 rowboat.cs.vu.nl 。它提供的信息包括 IP 地址、主要邮件存放处和次要邮件存放处。 
* 然后是一个针对一台计算机的表项，这台计算机自己不能接收邮件：
* 紧随其后的一个表项可能是指一台连接到 Internet的打印机。

## 1.3 Name servers

查询一个名字和找出其对应地址的过程称为***域名解析***[name resolution ]。

### A. authoritative record

当解析器需要查询一个域名，它就把该查询传递给一个本地域名服务器。如果需要寻找的域恰好落在该域名服务器管辖下，比如 top.cs.vu.nl 在 cs.vu.nl 的管辖下，则该域名服务器就返回***权威资源记录***。一个权威记录[ authoritative record]由管理该记录的权威部门提供，因此总是正确的。

### B. cached record

权威记录的权威性是相对缓存记录[cached record ]而言的，缓存的记录有可能过时。

### C. root name servers

There are 13 root DNS servers, unimaginatively called a-root-servers.net through m.root-servers.net. They have information about each top-level domain.



### D. name resolution example

如果被查询域在远端，比如 flits.cs.vu.nl 要找到华盛顿大学robot.cs.washington.edu 的 IP 地址，会发生什么？如果本地没有关于相关域的缓存信息，那么域名服务器启动一次远程查询。

1. 显示查询报文被发送到本地域名服务器[第一步]。查询中包含了被查询的域名、类型[A]和类[IN]。
2. 通过请求其中之一的根域名服务器来启动域名层次结构顶部的查询。这些域名服务器包含每个顶级域名的有关信息。为了与一个根服务器取得联系，每个域名服务器必须有一个或多个根域名服务器的信息。这个信息通常放在一个系统配置文件中，在 DNS 服务器启动时把该文件加载到 DNS 缓存。这个文件很简单，只是列出了关于根服务器的 NS[name server] 记录和相应的 A[IPv4] 记录。
3. 根域名服务器不可能知道在 uw 的一台机器的地址，可能还不知道 uw 的域名服务器。 但是，它必须知道 edu 域的域名服务器，因为 cs.washington.edu 属于 edu 域管辖下。在第 3 步，它返回查询的答案，其中包括了名字和 IP 地址。
4. 然后本地域名服务器继续尽职地执行任务。它将整个查询发给 edu 域名服务器[a.edu­-servers.net]。该域名服务器返回UW的域名服务器。上述过程显示在图中的第 4 步和第 5步。
5. 本地域名服务器把查询发送给UW的域名服务器[第 6 步]。 如果被查询的域名是英语系，则马上能找到答案，因为 uw 域包括了英语系。但是，计算 机科学系选择运行自己的域名服务器，因此该查询返回的是 uw 计算机科学系的域名服务 器和 IP 地址[第 7 步]。
6. 最后，本地域名服务器查询UW计算机科学系的域名服务器[第 8 步]。这台服务器是 cs.washington.edu 的***权威机构***，所以它必定有答案。它返回最终的答案[第 9 步]，即作为响应 flits.cs.vu.nl [第10步]转发的本地域名服务器。至此，查询的域名得到了解析。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20191217100055190.png" alt="image-20191217100055190" style="zoom:50%;" />

<img src="/Users/jones/Desktop/miaochenlu.github.io/assets/images/image-20200102104749552.png" alt="image-20200102104749552" style="zoom:50%;" />

> **根域名服务器**是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。在因特网上共有13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从a 一直到 m（前13 个字母）。
>
> **顶级域名服务器**负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。 
>
> **权限域名服务器**是负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。 
>
> **本地域名服务器**对域名系统非常重要。当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。每一个因特网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器。 

### E. Query machanism

#### i. recursive query

> 当主机 flits.cs.vu.nl 将查询发送给本地域名服务器后，该域名服务器就代替该主机处理域名解析工作，直到它返回所需的答案。这里的答案必须是完整的，它不能返回部分答案。这个机制称为递归查询[recursive query ]。
>
> some detailed explanation from stackExchange
>
> > If there are 2 DNS servers, DNS-A is the authority for domain-a, and DNS-B is the authority for domain-b
> >
> > Someone sends a DNS query to DNS-A for a lookup of domain-b. DNS-A would then be recursing by sending a request to DNS-B in order to lookup domain-b. Essentially, a recursive query is when a DNS server, on behalf of the client that sent the query, chase the trail of DNS in order to fulfill the request.

#### ii. iterative query

> 根域名服务器[和每个后续的域名服务器]并不是递归继续查询本地域名服务器。它只是返回一个部分答案，并移动到下一个查询操作。本地域名服务器负责继续解析，具体做法是发出进一步的查询报文。这个机制称为迭代查询[iterative query], 又称作重指引,返回的是最佳的查询点或者主机地址





#### iii. DNS Cache

> 所有的查询答案，包括所有的部分答案都会被缓存。
>
> 这样， 如果另一台 cs.vu.nl 主机需要查询 robot.cs.washington.edu，那么答案早就有了。
>
> 更妙的是， 如果在同一个域中的一台不同主机需要查询另一台主机，比如 galah.cs.washington.edu，那 么此次查询可直接发送到权威的域名服务器。类似地，针对 washington.edu 其他域的查询 也可以从 washington.edu 域名服务器直接开始。这种使用缓存答案的做法可大大降低一次 查询的步骤，并能提高查询性能。

`问题`{:.error}

> 高速缓存的答案不具权威性，因为在 cs.washington.edu 所做的信息变化将不会传播到世界上所有可能知道它的缓存。
>
> 出于这个原因，缓存的表项不应该生存得太长。这 就是为什么在每条资源记录中要包含 Time to live 宇段的原因。它告诉远程域名服务器可缓存本记录多长时间。如果某台机器己经多年使用相同的 IP 地址，将它的信息缓存 1 天可 能是安全的。而对于波动比较大的信息，几秒钟或一分钟后清除掉记录的做法或许更安全。



#### iv. UDP

> 域名系统采用的是 UDP
>
>  DNS消息通过 UDP 数据包发送，格式非常简单，只有查询和响应。域名服务器可用此数据包继续进行解析操作。



 Non-Recursive Queries are EnabledDNS cache窥探是一个获取已经被DNS服务器解析的请求的过程。如果我们想检查hostname是否被本地DNS网络解析，这将很有用。这意味着本地网络中的节点近期使用那台DNS服务器请求过hostname。从而可以窥探在某一个时间user访问了哪个页面。 
如果我莫使用一个非递归查询来解析一个已经解析的域名，那么DNS服务器对于cache窥探很敏感。为了检查DNS服务器是否对于DNS窥探敏感，我们可以尝试用非递归请求来查找一个域名：如果DNS服务器不知道那么它也不请求其他DNS服务器。 

# 2. 电子邮件

## 2.1 体系结构和服务

<img src="/Users/jones/Desktop/miaochenlu.github.io/assets/images/image-20200102094320059.png" alt="image-20200102094320059" style="zoom:50%;" />

上图是一个电子邮件系统的体系结构。他包括两类子系统：

* user agent

> user agent是一个程序。用户通过它和电子邮件系统交互。用户代理提供了一个图形界面，有时是一个基于文本和基于命令的接口。它包括了撰写邮件、回复邮件、显示入境邮件信息的手段，同时还提供了如何过滤、搜索和删除邮件的组织方式。把新邮件发送给邮件系统，并通过它传递的行为称为***邮件提交***（ mail submission ）。

* message transfer agent

> 邮件传输代理通常是系统进程。它们运行在邮件服务器机器的后台，并始终保持运行状态。它们的工作是通过系统自动将电子邮件从发送端移动到收件人，采用的协议是简单 邮件传输协议（ SMTP, Simple Mail Transfer Protocol ）。

{warning:.}

电子邮件系统的一个关键思想是将信封（ envelope ）与邮件内容区分开来

信封将消息封装成邮件，它包含了传输消息所需要的所有信息，例如目标地址、优先级和安全等级。消息传输代理根据信封来进行路由，就好像邮局的做法一样。

信封内的消息由两部分组成：邮件头（header）和邮件体（ body）。邮件头包含用户代理所需的控制信息。邮件体则完全提供给收件人，代理和邮件传输代理都不在意邮件体包含了什么信息。

<img src="/Users/jones/Desktop/miaochenlu.github.io/assets/images/image-20200102095124155.png" alt="image-20200102095124155" style="zoom:50%;" />



## 2.2 user agent

用户代理是一个程序（有时也称为***电子邮件阅读器***），它接收各种各样命令，从接收和 回复邮件到操纵邮箱的命令



<img src="/Users/jones/Desktop/miaochenlu.github.io/assets/images/image-20200102095840850.png" alt="image-20200102095840850" style="zoom:50%;" />

## 2.3 邮件格式Message Formats

* RFC 5322 – The Internet Message format

> 邮件由一个基本的信封（作为SMTP的一部分由RFC 5321 描述)、数个头字段、一个空行和邮件体组成。头的每个字段（逻辑上）由一行 ASCII 文本组成，其中包括域名、一 个冒号，对于大多数头的字段来说还包括一个值

* MIME (Multipurpose Internet Mail Extensions)

> MIME的基本思想是继续使用RFC 822 格式（在RFC 5322 之前 MIME伍就己经被提出来了），但在邮件体中增加了结构性，并且为传送非 ASCII 码的邮件定义了编码规则

base64 encoding

每24位编成一组，一组被分成4个6bits的单元。

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102111814441.png" alt="image-20200102111814441" style="zoom:40%;" />

## 2.4 邮件传送

<img src="/Users/jones/Desktop/miaochenlu.github.io/assets/images/image-20200102105017535.png" alt="image-20200102105017535" style="zoom:50%;" />

发送邮件的协议: SMTP

> 这是一个简单的***ASCII协议***：[因此要用base64将二进制数据转化为ASCII码]
>
> 端口号:***25***
>
> ***TCP连接***
>
> 

读取邮件的协议：POP3 和 IMAP

> 1. 发件人调用 PC 机中的用户代理撰写和编辑要发送的邮件。
> 2. 发件人的用户代理把邮件用 SMTP 协议发给发送方邮件服务器，
> 3.  SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。
> 4.  发送方邮件服务器的 SMTP 客户与接收方邮件服务器的 SMTP 服务器建立 TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。
> 5.  运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。 
> 6.  收件人在打算收信时，就运行 PC 机中的用户代理，使用 POP3（或 IMAP）协议读取发送给自己的邮件。  

也可以基于web

<img src="/Users/jones/Library/Application Support/typora-user-images/image-20200102112054589.png" alt="image-20200102112054589" style="zoom:50%;" />

# 3. World wide web

## 3.1 客户端







### cookies

 A cookie may contain up to 5 fields 

* **Domain**: where the cookie came from 

- **Path**: which parts of the server’s file tree may use it 
- **Content**: *name=value* lists 
- **Expires**: when the cookie expires. 
- **Secure**: can be set to indicate that the browser may only return the cookie to a server using a secure transport. 



### Static Web Pages: HTML

















