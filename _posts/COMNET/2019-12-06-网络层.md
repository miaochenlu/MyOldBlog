---
layout: article
title: Computer network--网络层
key: page-COMNET5
cover: https://miaochenlu.github.io/picture/IMG_2759(20191201-193115).png
mode: immersive
header:
  theme: dark
article_header:
  type: overlay
  theme: dark
  background_image:
    src: ../picture/IMG_2759(20191201-193115).png
---



A post has an article header overlay with a background image in immersive mode with a translucent header.

<!--more-->

<style>
  .page__header .header__brand path {
    fill: rgba(255, 255, 255, .95);
  }
</style>

<br/>

# 1. 网络层的设计问题

## 1.1 存储转发数据包交换

阴影椭圆中的是网络服务提供商(ISP)的设备

如果一台主机想要发送一个数据包，他就将数据包传输给最近的路由器。

在该数据包到达路由器，并且路由器的链路层完成了对它校验和的验证之后，它先被存储在路由器上；然后沿着路径被转发到下一个路由器，直至到达目标主机

<center><img src="https://miaochenlu.github.io/picture/image-20191119095439198.png" alt="image-20191119095439198" style="zoom: 25%;" /></center>

## 1.2 提供给传输层的服务

1. 向上提供的服务应该独立于路由器技术。
2. 应该向传输层屏蔽路由器的数量、类型和拓扑关系。 
3. 传输层可用的网络地址应该有一个统一编址方案，甚至可以跨越 LAN 和 WAN。



## 1.3 无连接服务的实现





# 2. 路由算法

路由算法是网络层软件的一部分，负责确定一个入境数据包应该被发送到哪一条输出线路上。



路由和转发这两个功能的区别

> * 路由
>
>   涉及一个网络的**所有路由器**，经由路由选择协议共同交互，来决定分组从源到目的地结点所采取的路径
>
> * 转发
>
>   分组在**单一的路由器**从一条入链路到一条出链路到传送



路由算法可以分成两类

> * 非自适应算法
>
>   * 自适应算法



## 2.1 优化原则

最优化原则：

> 如果路由器J在从路由器I到路由器K的最优路径上，那么从J到K到最优路径必定遵循同样的路由

<center><img src="https://miaochenlu.github.io/picture/image-20191129193218868.png" alt="image-20191129193218868" style="zoom:50%;" /></center>

直接推论：从所有的源到一个指定目标的最优路径的集合构成了一棵以目标节点为根的树。这样的树称为***汇集树[sink tree]***

路由算法的目标就是为所有的路由器找到汇集树，并根据汇集树来转发数据包

<center><img src="https://miaochenlu.github.io/picture/image-20191129193740688.png" alt="image-20191129193740688" style="zoom:50%;" /></center>

## 2.2 最短路径算法

可以选择距离、带宽、平均流量、通信成本、平均延迟等作为路径的权重

使用Dijkstra算法

<table>
  <tr>
    <td><img src="https://miaochenlu.github.io/picture/image-20191202182043293.png" alt="image-20191202182043293" style="zoom:50%;" /></td>
    <td><img src="https://miaochenlu.github.io/picture/image-20191202182130071.png" alt="image-20191202182130071" style="zoom:50%;" /></td>
  </tr>
  <tr>
    <td><img src="https://miaochenlu.github.io/picture/image-20191202182159979.png" alt="image-20191202182159979" style="zoom:50%;" /></td>
    <td><img src="https://miaochenlu.github.io/picture/image-20191202182231738.png" alt="image-20191202182231738" style="zoom:50%;" /></td>
  </tr>
  <tr>
    <td><img src="https://miaochenlu.github.io/picture/image-20191202182426228.png" alt="image-20191202182426228" style="zoom:50%;" /></td>
  </tr>
</table>



## 2.3 泛洪算法[flooding]

flooding将每一个入境数据包发送到除了该数据包到达的那条线路以外的每条出境线路。

泛洪法会产生大量的重复数据包。事实上，除非采取某些措施来抑制泛洪过程，否则将会产生无限多的数据包。

* 在每个数据包的header中设置一个hop counter

  > 每经过一跳该计数器减一，当计数器到达 0 时就丢弃该数据包。
  >
  > 理想情况下，跳计数 器的初始值应该等于从源端到接收方之间路径的长度。如果发送方不知道该路径有多长， 它可以将计数器的初始值设置为最坏情形下的长度，即网络的直径。

* keep track of which packets have been flooded, to avoid sending them out a second time.

<br/>

## 2.4 距离矢量算法[Distance Vector]

> 每个路由器维护一张表（即 一个矢量〉，表中列出了当前己知的到每个目标的最佳距离，以及所使用的链路。
>
> 这些表通过邻居之间相互交换信息而不断被更新，最终每个路由器都了解到达每个目的地的最佳链路。

<a href="https://blog.csdn.net/u013007900/article/details/45565389">距离矢量算法详解</a>

### i. count-to-infinity problem

虽然DV算法总是能够收敛到正确的答案，但速度可能非常慢。尤其是它

* 对于好消息的反应非常迅速
* 而对于坏消息的反应异常迟缓。

#### i.A 来看一下对好消息是怎么反应的

<center><img src="https://miaochenlu.github.io/picture/image-20191202184133049.png" alt="image-20191202184133049" style="zoom: 40%;" /></center>

以跳数作为路径的权重

假设A最初处于停机状态，考虑A突然启动的情况

> 1. 一开始，B、C、D、E都不和A连通，所以都是“·”状态
>
> 2. 在第一次交换时， B 知道它左边的邻居到 A 的延迟为 0 。于是 B 在它的路由表中建立一个表项，说明 A 离它一跳远。所有其他的路由器仍然认为 A 是停机的。
> 3. 在接下去的交换中，C知道B有一条路径通向A，并且路径长度为1，所以它更新自己的路由表，指明它到 A 的路径长度为 2，但是 D 和 E 要到以后才能听到这个好消息。

从上面的例子可以看出

好消息扩散的速度是每交换一次往远处走一跳。如果一个网络中最长路径是 N 跳，那么经过 N 次交换之后，每个路由器都将知道新恢复的链路和路由器。



#### i.B 再来看一下对坏消息的反应

<center><img src="https://miaochenlu.github.io/picture/image-20191202185212842.png" alt="image-20191202185212842" style="zoom:40%;" /></center>

以跳数作为路径的权重

假设A最初处于启动状态，考虑A突然停机或者A和B之间链路断了的情况

> 1. 一开始，B、C、D、E都有通向A的链路
> 2. 在第一次信息交换时， B 没有听到来自 A 的任何信息。幸运的是， C 说“别担心，我有一条通向 A 的长度为 2 的路径”， B 并不怀疑 C 如何到达A。因此， B 认为它可以通过 C 到达 A，路径长度为 3 。在第一次交换之后， D 和 E 并不更新它们的 A 表项。
> 3. 在第二次信息交换时， C 注意到，它的每一个邻居都声称有一条通向 A 的长度为 3 的路径。它随机地挑选出一条，并且将它到A的距离更新为4。
> 4. 通过后续的交换，可以得到图中余下的记录历史。

逐渐地，所有的路由器都会趋向无穷大，但是所需交换的次数依赖于代表无穷大的数值。由于这样的原因，明智的做法是将无穷大设置为最长的路径+1

<a href="https://blog.csdn.net/tianlongtc/article/details/80261581">毒性逆转</a>

<br/>

## 2.5 链路状态路由[link state routing]

1. 发现它的邻居节点，并了解其网络地址。
2. 设置到每个邻居节点的距离或者成本度量值。
3. 构造一个包含所有刚刚获知的链路信息包。
4. 将这个包发送给所有其他的路由器，并接收来自所有其他路由器的信息包。
5. 计算出到每个其他路由器的最短路径。

<br/>

### i. 发现邻居

首先路由器要找到它的邻居。

路由器在每一条点到点线路上发送一个特殊的 HELLO 数据包，线路另一端的路由器应该返回一个应答说明自己是谁。

<br/>

### ii. 设置链路成本

需要每条链路以距离、成本、延迟度量。

测定延迟的方法是：

> 通过线路给另一边发送一个特殊的 ECHO 数据包，要求对方立即发回。通过测量往返时间再除以 2

<br/>

### iii. 构造链路状态包[link state packets]

<center><img src="https://miaochenlu.github.io/picture/image-20191203080937476.png" alt="image-20191203080937476" style="zoom: 33%;" /></center>

#### iii.A link state packets的结构

* 发送方的标识符
* 序号[Seq]
* 年龄[Age]
* 邻居列表，对于每个邻居，同时给出到这个邻居的延迟

#### iii.B 什么时候构造数据包

* 周期性地创建数据包
* 每当发生某些重要的事情时才创建数据包，比如一条线路断掉或者一个邻居节点停机...

<br/>

### iv. 分发链路状态包

链路状态路由算法最技巧的部分在于分发链路状态数据包

<br/>

思路：

泛洪将link state packets分发给所有路由器。为了控制flooding规模，每个数据包都有一个序号。

* Sequence number increments for each new pkt sent.

* Routers keeps track of all the (source router, sequence) pairs they see.

* If pkt is new, forward to lines except the incoming one

* Else, discard.

* If sequence number is lower than highest one seen so far, reject as obsolete.

* To include age of each packet and decrement it once per second. If age hits 0, discard the information.

<br/>

可能产生的问题与解决方法

* 如果序号绕回，可能会产生混淆。

  > 解决方案：使用一个 32 位的序号。

* 如果一个路由器崩溃了，那么它将丢失所有的序号记录表。如果它再从 0 开始， 那么，下一个数据包将被作为重复数据包而拒绝。

  再次，如果一个序号被破坏了，比如发送方发送的序号为 4，但是由于产生了 1 位错 误，所以接收方看到的序号是 65540 ，那么，序号从 5 到 65540 的数据包都将被当作过时数据包而拒绝接受，因为接收方认为当前的序号是 65540 。

  > 解决方案：在每个数据包的序号之后包含一个年龄[ age ]宇段， 并且每秒钟将年龄减 1 。当年龄字段的值被减到 0 时，来自路由器的该信息将被丢弃。通常情况下，每隔一段时间，比如说 10 秒，一个新的数据包就会到来：

<center><img src="https://miaochenlu.github.io/picture/image-20191203083626941.png" alt="image-20191203083626941" style="zoom:40%;" /></center>



### v. Computing the new routes

Once a router has accumulated a full set of link state packets, it can construct the entire subnet graph because every link is represented.

在路由器本地运行Dijkstra算法，来计算路由





### LS-DV的比较

<center><img src="https://miaochenlu.github.io/picture/image-20191203084340533.png" alt="image-20191203084340533" style="zoom: 40%;" /></center>



## 2.6 层次路由

为什么要分层：

> 随着网络规模的增长，路由器的路由表也成比例地增长．不断增长的路由表不仅消耗路由器内存，而且还需要更多的 CPU 时间来扫描路由表以及更多的带宽来发送有关的状态 报告。当网络增长到一定时可能会达到某种程度，此时每个路由器不太可能再为其他每一个路由器维护一个表项。所以 ， 路由不得不分层次进行

<br/>

Two level routing:

>* Every router knows all the details about how to route packets to destinations within its own region
>
>* but knows nothing about the internal structure of other regions.

<br/>

Multiple-level routing

> regions->clusters->zones->groups->...

<br/>

下面是一个two-level routing的例子，其中有5个区域

路由器1A的完整路由表[图b]有17个表项。

如果采用分级路由，则路由器如图c所示，路由表有7项

<center><img src="https://miaochenlu.github.io/picture/image-20191203084908185.png" alt="image-20191203084908185" style="zoom:35%;" /></center>

应该分成多少层

> 对于一个包含 N 个路由器的网络，最优的层数是 ln N，每个路由器所需的路由器表项是 elnN 个。

例如，考虑一个具有 720 个路由器的子网。如果没有分层，每个路由器需要 720 个路由表项

如果子网被分 成 24 个区域，每个区域 30 个路由器，那么每个路由器只需要 30 个本地表项，加上 23 个 远程表项，总共 53 个表项

如果采用三级层次结构，总共 8 个簇，每个簇包含 9 个区域，每个区域 10 个路由器，那么，每个路由器需要 10 个表项用于记录本地路由器， 8 个表项用于到同一簇内其他区域的路由， 7 个表项用于远程的簇，总共 25 个表项。



## 2.7 广播路由

广播：to send a packet to all destinations simultaneously.

广播的方法

* 让源机器给每一个目标单独发送一个数据包

  > 不仅浪费带宽，而且要求源机器拥有所有目标机器的完整地址

* 多目标路由[multidestination routing]

  > 每个数据包包含一组目标地址，或者一个位图，由该位图指定所期望到达的目标。
  >
  > 当一个数据包到达一个路由器时， 路由器检查数据包携带的所有目标，确定哪些输出线路是必要的[只要一条输出线路是到达至少一个目标的最佳路径，那么它就是必要的]。
  >
  > 路由器为每一条需要用到的输出线路生成一份该数据包新的副本，在这份副本中只包含那些使用这条线路的目标地址。实际上，原来的目标集合被分散到这些输出线路上。
  >
  > 在经过了足够多的跳数之后，每个数据包将只包含一个目标地址，因此可以被当作普通的数据包来对待。
  >
  >  
  >
  > 优点：当多个数据包必须遵循同样的路径时，其中一个数据包承担了全部的费用，而其他的数据包则是免费搭载。因此，网络带宽的利用率更高。
  >
  > 缺点：依然要求源端知道全部的目标地址，对于路由器来说，要确定从哪些线路转发多目标数 据包的工作量太大，尤其是处理多个不同的数据包时。

* flooding

* 逆向路径转发[reverse path forwarding]

  当一个广播数据包到达一个路由器时，路由器检查它到来的那条线路是否正是通常用来给广播源端发送数据包用的那条线路。

  * 如果是，则该广播数据包是沿着最佳路径被转发过来的，因而是到达当前路由器的第一份副本。该路由器将该数据包转发到除了到来的那条线路之外的所有 其他线路上。
  * 如果广播数据包是从其他任何一条并非首选的到达广播源的线路入境的话，该数据包被当作一个可能的重复数据包而丢弃。

  <center><img src="https://miaochenlu.github.io/picture/image-20191205155744495.png" alt="image-20191205155744495" style="zoom:40%;" /></center>

  <br/>

  <center><img src="https://miaochenlu.github.io/picture/image-20191205154558002.png" alt="image-20191205154558002" style="zoom:50%;" /></center>

  >(a)部分显示了一个网络， (b )部分显示了该网络中路由器 ***I*** 的一棵汇集树，图(c部分显示了逆向路径算法是如何工作的。
  >
  >1. 在第一跳， I 发送数据包给 F、 H、 J 和 N，如树中第二行所示。这些数据包中的每一个都是在通向 I 的首选路径（假定首选的路径都沿着汇集树)到来的， 这点用字母外面加一个圆圈来表示。
  >2. 在第二跳，共产生了 8 个数据包，其中，在第一跳接收到数据包的路由器各产生 2 个数据包。结果，所有这 8 个数据包都到达了以前没有访问过的路由器，其中 5 个是沿着首选线路到来的。
  >3. 在第三跳所产生的 6 个数据包中，只有 3 个是沿首选路径（在 C、 E 和 K）到来的，其他的都是重复数据包。在经过五跳和 24 个数据包以 后，广播过程终止。相比之下，如果完全沿着汇集树的话，只需要 4 跳和 14 个数据包。

* spanning tree

改进了逆向路径转发。

每个路由器都知道它的哪些线路属于生成树，它就可以将一个人境广播数据包复制到除了该数据包到来的那条线路之外的所有***<u>生成树线路</u>***上。

> 和逆向路径转发相比，逆向路径转发并不只转发到生成树线路，还会转发到其他线路，这些数据包会被认为是可能的重复数据包而被丢弃；而生成树算法没有丢弃问题

<br/>

## 2.8 组播路由[multicast]

我们需要有一种办法能够 给明确定义的组发送消息，这些组的成员数量虽然很多，但相比整个网络规模却很小。

<center><img src="https://miaochenlu.github.io/picture/image-20191205155836717.png" alt="image-20191205155836717" style="zoom: 40%;" /></center>

通过修建广播生成树把不通往组成员的链路从树中删掉。修建结果得到的是一颗有效的组播生成树。

<br/>

## 2.9 选播路由



# 3. 拥塞控制算法

### i. 什么是拥塞[congestion]

> 网络中存在太多的数据包导致数据包被延迟延迟和丢失，从而降低了传输性能，这种情况称为拥塞
>
> 网络层和传输层共同承担着处理拥塞的责任。
>
> * 由于拥塞发生在网络内，正是网络层直接经历着拥塞，而且必须由它最终确定如何处理过载的数据包。
> * 然而，控制拥塞的最有效方法是减少传输层注入网络的负载。这就需要网络层和传输层共同努力协同工作。

### ii. 拥塞的影响

<center><img src="https://miaochenlu.github.io/picture/image-20191202212045404.png" alt="image-20191202212045404" style="zoom:30%;" /></center>

* 当主机发送到网络的数据包数量在其承载能力范围之内时， 送达的数据包数与发送的数据包数成正比例增长
* 然而，随着负载接近承载能力，偶尔突发的流量填满了路由器内部的缓冲区，因而某些数据包会被丢失。这些丢失的数据包消耗了部分容量，因此，送达的数据包数量低于理想曲线。网络现在开始拥塞。


* 除非网络是精心设计的，否则它极有可能会遭遇拥塞崩溃 [Ccongestion collapse ]，表现为随着注入负载的增加到超出网络的容量，网络性能骤降。

<br/>

拥塞控制和流量控制

> * 拥塞控制的任务是确保网络能够承载所有到达的流量。这是一个全局性的问题，涉及各方面的行为，包括所有的主机和所有的路由器。
> * 与此相反，流量控制只与特定的发送方和特定的接收方之间的点到点流量有关。它的任务是确保一个快速的发送方不会持续地以超过接收方接收能力的速率传输数据。

<br/>

## 3.1 拥塞控制的途径

拥塞的出现意味着负载（暂时）大于资源（在网络的一部分〉可以处理的能力。

很自然能想到两个解决方案

* 增加资源
* 减少负载。

<center><img src="https://miaochenlu.github.io/picture/image-20191202215504805.png" alt="image-20191202215504805" style="zoom: 33%;" /></center>

## 3.2 流量感知路由[traffic-aware routing]

把链路权重设置成一个（固定）链路带宽、传输延迟、（可变）测量负载或平均排队延迟的函数。在所有其他条件都相同的情况下，最小权重的路径更青睐那些***轻负载***的路径。

<br/>

## 3.3 准入控制[admission control]

一种广泛应用于虚电路网络，防止出现拥塞的技术是准入控制（ admission control ）

思想：

> 除非网络可以携带额外的流量而不会变得拥塞，否则不再建立新的虚电路。因此，任何建立新的虚电路的尝试或许会失败。

常用：<u>leaky bucket</u> or <u>token bucket</u>



## 3.4 流量调节[traffic throttling]

在 Internet 和许多其他计算机网络中，发送方调整它们的传输速度以便发送网络能实际传送的流量。在这种设置下，网络的目标是在拥塞发生之前正常工作。

而当拥塞迫在眉睫，它必须告诉发送方紧急刹车放慢传输速度。这种反馈是一种常态而不是针对特殊情况的一种处理。



### 限制流量的方法

要解决两个问题：

#### 1. 路由器必须确定何时快要接近拥塞，最好在拥塞发生之前能确定[排队时延]

> 解决方法：每个路由器连续监测它正在使用的资源。可以输出在路由器内缓冲的排队数据包。路由器内部的排队延迟直接捕获了数据包经历过的任何拥塞情况
>
> 为了维持良好的排队延迟估计d, 假设s表示瞬时队列长度的样值, d可以定期生成，按如下方式更新，其中$\alpha$是一个参数，加权移动平均
>
> $d_{new}=\alpha d_{old}+(1-\alpha)s$
>
> 如果d升高到某一个阈值之上，则路由器就要开始注意拥堵了

#### 2. 路由器必须及时把反馈消息传递给造成拥塞的发送方

**2.A 抑制包**

> * 路由器选择一个被拥塞的数据包，给该数据包的源主机返回一个抑制包（choke packet ）。
>
>   抑制包中的***<u>目标地址</u>***取自该拥塞数据包。同时，在原来的拥塞数据包上添加一个***<u>标记</u>***（设置头部中的一位），因而它在前行的路径上不会产生更多的抑制包。
>
> * 数据包的转发过程如同平常 一样。 
>
> * 当源主机收到了抑制包，按照要求它必须减少发送给指定目标的流量，比如说减少 50% 。
>
> 在数据报网络中，发生拥塞时路由器简单地随机选择一个数据包，很有可能就把抑 制包发给了快速发送方，因为发送方的速度越快，它的数据包排队在路由器队列中的数目就越多。

<center><img src="https://miaochenlu.github.io/picture/image-20191205230214522.png" alt="image-20191205230214522" style="zoom:50%;" /></center>

**2.B 逐跳后压[hop-by-hop choke packets]**

因为传播延迟的影响，拥塞信号发出到起作用之间已经有很多新的数据包注入了网络。

因此，可以让抑制包在沿途的每一跳都发挥作用



<center><img src="https://miaochenlu.github.io/picture/image-20191205232440838.png" alt="image-20191205232440838" style="zoom:50%;" /></center>

**2.C Explicit Congestion Notification [ECN]**

> * 路由器可以在它转发的任何数据包上打上标记[设置数据包头的某一个标志位]发出信号，表明它正在经历着拥塞。
>
> * 当网络传递数据包时， 接收方可以注意到有个拥塞己经发生，在它发送应答包时顺便告知发送方。
>
> * 然后发送方可以像以前那样紧急刹车降低传输速率。

<center><img src="https://miaochenlu.github.io/picture/image-20191205231809305.png" alt="image-20191205231809305" style="zoom:50%;" /></center>





<br/>

## 3.5 负载脱落[load shedding]

当路由器因为来不及处理数据包而面临被这些数据包淹没的危险时，就将它们丢弃。

关键问题：选择丢弃哪个数据包

* 旧的比新的好，丢新包[wine策略]
* 新的比旧的好[milk 策略]



### 随机早期检测[random early detection]

为什么早期：

> 在拥塞刚出现苗头时就处理它比等拥塞形成之后再设法解决它更加有效，即在所有的缓冲空间都精疲力竭之前丢弃数据包。

为什么随机:

> 随机选择丢弃的数据包使得快速发送方发现丢包的可能性更大。发送方没有收到期待的确认信息时，就会认为丢包了，然后传输协议将放慢速度。因此，丢失的数据包起到了传递抑制包的同样作用

<br/>

# 4. 服务质量[QUALITY OF SERVICE ]

A flow is a stream of packets from a source to a destination.

The needs of each flow can be characterized by fourprimary parameters:

* Reliability(可靠性)

* 延迟(Delay)

* 抖动(Jitter)

* 带宽(Bandwidth)

## 4.1 应用需求

<center><img src="https://miaochenlu.github.io/picture/image-20191205233904014.png" alt="image-20191205233904014" style="zoom:30%;" /></center>

## 4.2 流量整形[traffic shaping]

<center><img src="https://miaochenlu.github.io/picture/image-20191206000433623.png" alt="image-20191206000433623" style="zoom:50%;" /></center>



# 6

## 6.1 IPv4协议

IP数据包包含：

* 一个头[20bytes的定长部分和可选的变长部分组成]
* 一个正文

<center><img src="https://miaochenlu.github.io/picture/image-20191126085207750.png" alt="image-20191126085207750" style="zoom:50%;" /></center>

* version: 数据报属于协议的哪个版本, IPv4该字段总是4

* IHL: 由于头的长度不固定，IHL字段指明头到底有多长，以32bits长度为单位。

  IHL的最小值为5，5words=160bits=20bytes, 这表明头没有options字段。

  IHL的最大值为5

* Differentiated services: 
  - **Type of service** (past): 3 for priority, 3 for Delay, Throughput, and Reliability, and 2 unused. 
  -  **Differentiated services** (now): 6 for service class, 2 for congestion (e.g. ECN). 
* Total length: the length of header and data. 最大值为65535bytes
* Identification: 让目标主机确定一个新到达的分段属于哪一个数据报。同一个数据报的所有段包含同样的表示值

* 灰色的部分是一个未使用的位
* DF： Don't fragment。不分段标志位
* MF：more fragment。除了最后一个段，其他段都必须设置这一位
* Fragment: 指明该段在数据报中的位置。除了数据报的最后一个段，其他所有段的长度必须是8bytes的倍数
* Time to live: 限制数据报生存期的计数器。计数单位被设置为秒。在每一跳上该计数器必须被递减。实际上是***跳计数器***，当他递减到0时，数据报就被丢弃。
* Protocol: 指明该将它交给哪个传输进程[TCP UDP ...]
* Header checksum: 
* Source address: 源IP地址
* Destination address： 目标IP地址
* options

<center><img src="https://miaochenlu.github.io/picture/image-20191126090914574.png" alt="image-20191126090914574" style="zoom:50%;" /></center>

<a href="https://blog.csdn.net/ztguang/article/details/70949781">OSPF protocol</a>



## 6.2 IP地址

一个IP地址并不真正指向一台主机，而是指向一个网络接口，所以如果一台主机在两个网络上，它必须有两个IP地址。然而大多数主机都连在一个网络，因而只有一个IP地址。

路由器有多个接口，从而有多个IP地址



### A.前缀

IP地址具有层次性，可以将IP地址分成两部分

* 高位可变长网络
* 地位的主机

<center><img src="https://miaochenlu.github.io/picture/image-20191126091437663.png" alt="image-20191126091437663" style="zoom:50%;" /></center>



**子网掩码**可以与一个IP地址进行AND操作，提取出IP地址的network部分

如上图，子网掩码为255.255.255.0



### B.子网

<center><img src="https://miaochenlu.github.io/picture/image-20191126091938551.png" alt="image-20191126091938551" style="zoom:50%;" /></center>



### C. CIDR 无类域间路由

<center><img src="https://miaochenlu.github.io/picture/image-20191126113616524.png" alt="image-20191126113616524" style="zoom: 33%;" /></center>



Question:

<center><img src="https://miaochenlu.github.io/picture/image-20191126113649618.png" alt="image-20191126113649618" style="zoom: 33%;" /></center>

***对于A:***

<center><img src="https://miaochenlu.github.io/picture/image-20191126114956080.png" alt="image-20191126114956080" style="zoom:50%;" /></center>

因为需要1024个地址，所以host有10位，子网掩码是22位

202.101.0.0/22

***对于B:***

<center><img src="https://miaochenlu.github.io/picture/image-20191126115309939.png" alt="image-20191126115309939" style="zoom:50%;" /></center>

host有11位，子网掩码是21位

202.101.8.0/21

***对于C:***

<center><img src="https://miaochenlu.github.io/picture/image-20191126115323260.png" alt="image-20191126115323260" style="zoom:50%;" /></center>

host有11位，子网掩码是21位

202.101.16.0/21

### E. NAT





## 6.4 IPv6 Protocol

IPv6协议采用128位地址，基本在未来任何时间都不可能出现地址短缺问题



### 主要的IPv6头[40bytes]

<center><img src="https://miaochenlu.github.io/picture/image-20191126120754968.png" alt="image-20191126120754968" style="zoom: 40%;" /></center>

* version: 对于IPv6,总是6

* Differentiated services: 区分数据包的服务类别

* Flow label: 为源端和接收方提供了一种建立伪连接的方式，即源端和接收方把一组具有同样需求并希望得到网络同等对待的数据报打上标记。
* payload length: 数据的字节数，这里是不包括头的，和IPv4不一样
* Next header: 指明当前头后还有哪种扩展头。如果当前的头是最后一个IP头，那么下一个头字段指定了该数据报将被传递给哪个传输协议处理(TCP, UDP)
* Hop limit: 跳数限制，相当于IPv4的TTL

* entension

IPv6地址的书写

**8** groups of **4** hexadecimal digits with colons between the groups

e.g. 8000:0000:0000:0000:0123:4567:89AB:CDEF

优化

1. leading zeros within a group can be omitted

   0123可以写作123

2. one or more groups of 16 zero bits can be replaced by a pair of colons

   8000::123:4567:89AB:CDEF

3. IPv4 addresses can be written as a pair of colons and an old dotted decimal number

   ::192.31.20.46





## 6.4 Internet控制协议

### ICMP---Internet Control Message Protocol

当路由器在处理一个数据包的过程中发生了意外，可以用过ICMP向数据包的源端报告有关事件

ICMP还可以用来测试Internet



<center><img src="https://miaochenlu.github.io/picture/image-20191129174803743.png" alt="image-20191129174803743" style="zoom:50%;" /></center>



### ARP---The address resolution protocol

作用是：将IP地址解析为MAC地址

为什么同时需要IP地址和MAC地址呢？

<a href="https://www.jianshu.com/p/0ce15c07b294">IP/MAC address</a>



ip地址负责标记发送方和接收方，MAC地址负责传输过程中的分段传送，比如下一跳的MAC地址。

<a href="https://blog.csdn.net/u010164190/article/details/79446575">ARP详解</a>

<a href="https://blog.csdn.net/lm409/article/details/80299823">ARP详解2</a>



### DHCP---Dynamic Host Configuration Protocol

<a href="https://blog.csdn.net/wuruixn/article/details/8282554">DHCP协议的工作过程</a>



















