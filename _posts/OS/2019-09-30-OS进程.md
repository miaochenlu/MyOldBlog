---
title: "OS--进程"
tags: Operating-system
key: page-OS2

---

<!--more-->

# 进程

# 1 概念

不正式地说：进程是执行中的程序（activity entity, a running program)

***进程和程序之间的关系怎么理解***？ 

> 想想一个会做蛋糕的计算机科学家（处理器CPU）正在为他女儿烘焙蛋糕。
>
> 他有制作生日蛋糕的食谱（程序）
>
> 厨房里有需要的原料：面粉、鸡蛋、糖、香草汁（输入数据）
>
> 这个例子中的进程就是计算机科学家阅读食谱，取来原来以及烘焙蛋糕的一系列动作的总和
>
>  
>
> 假设计算机科学家的儿子跑进来，说他被蜜蜂蛰了。
>
> 计算机科学家就记录下自己照着食谱做到哪里了（保存进程的当前状态）
>
> 然后拿出一本急救手册，按照其中的指示处理蛰伤
>
>  
>
> 这里可以看到处理器从一个进程（做蛋糕）切换到另一个高优先级的 进程（实施医疗救治）每个进程有各自的程序（食谱/医疗手册）。蜜蜂蛰伤处理完之后，计算机科学家由回来做蛋糕，从他离开时的那一步做下去。



进程包括：

* 程序代码（文本段（代码段））

* 当前活动（通过程序计数器的值和处理器寄存器的内容来表示）

* 堆栈段（包括临时数据，如：函数参数、返回地址、局部变量）

* 数据段（包括全局变量）

* 堆：进程运行期间动态分配的内存

<center><img src="https://miaochenlu.github.io/picture/1569219440814.png" alt="1569219440814" style="zoom: 67%;" /></center>
<br/>

<center><img src="https://miaochenlu.github.io/picture/1569656131801.png" alt="1569656131801" style="zoom:50%;" /></center>

## 1.1 进程状态

每个进程可能处于下列状态之一：

* New新的：进程正在被创建
* Running运行：指令正在被执行
* Ready就绪：进程等待分配处理器
* Waiting等待：进程等待某个时间的发生（如I/O完成)
* Terminated终止：进程完成执行

{:.warning}

一次只有一个进程处于running状态，但是许多进程可以处于ready或者waiting状态

<center><img src="https://miaochenlu.github.io/picture/1569220338728.png" alt="1569220338728" style="zoom:50%;" /></center>



* 运行-->等待：进程发现自己无法继续执行下去。在某些系统中，进程需要执行一个系统调用(block or pause)来进入等待

* 运行-->就绪：由进程调度器引起，调度器认为运行进程占用处理机的时间已经足够长，决定让其他进程占用处理机
* 就绪-->运行：系统已经让其他进程享有了他们应有的CPU时间而重新轮到该进程来占用处理机时间
* 等待-->就绪：当一个进程等待的外部时间发生时（如一些输入到达）



**调度器的主要任务**：哪个进程应当运行，以及它应该运行多长时间。

<center><img src="https://miaochenlu.github.io/picture/1569655670685.png" alt="1569655670685" style="zoom:50%;" /></center>



举个例子：

```powershell
cat chapter1 chapter2 chapter3 | grep tree
```



一个进程运行cat，将三个文件链接并输出；第二个进程运行grep，他从输入中选择所有包含单词“tree"的行。

在执行这一行shell时，grep命令可以已经准备好了，但是cat还没有完成，所以grep就会被阻塞



## 1.2 进程控制块(PCB)

为了实现进程模型，操作系统维持一张表格（一个结构数组），即 **进程表**。

每个进程占用一个进程表项（**称为进程控制块（process control block PCB)**）

<br/>

每个进程在操作系统内用进程控制块来表示，他包含很多和一个特定进程相关的信息

<center><img src="https://miaochenlu.github.io/picture/1569221812651.png" alt="1569221812651" style="zoom:70%;" /></center>
信息有：

* 进程状态：new,ready, running,waiting,exit
* 程序计数器：表示进程要执行的下个指令的地址
* CPU寄存器：累加器？堆栈指针？
* CPU调度信息：进程优先级、调度队列的指针、其他调度参数
* 内存管理信息：基址和界限寄存器、页表
* 记账信息：CPU时间、实际使用时间。。。
* I/O状态信息



<center><img src="https://miaochenlu.github.io/picture/1569657162817.png" alt="1569657162817" style="zoom:70%;" /></center>

# 2 进程调度

### 2.1 调度队列

* job queue: set of all processes in the system
* ready queue: set of all processes residing in main memory, ready waiting to execute
* device queue: set of processes waiting for an I/O device

队列通常用链表来表示，其头节点指向链表的第一个和最后一个PCB块的指针。每个PCB包括一个指向就绪队列的下一个PCB指针域

#### linux中的进程表示

PCB通过task_struct结构体来表示

```c
pid_t pid;					//process identifier
long state;					//state of the process
unsigned int time_slice;	//scheduling information
struct files_struct *files;	//list of open files
struct mm_struct *mm;		//address space of this process
```

进程的状态通过`long state`表示，在Linux内核中，所有活动的进程是通过`task_struct`的双向链表来表示的。内核为当前正在运行的进程保存了一个指针(current)

<center><img src="https://miaochenlu.github.io/picture/1569657118170.png" alt="1569657118170" style="zoom:67%;" /></center>
内核如何操作呢？

> 如果操作系统想把当前运行的状态值修改为new_state,如果current是当前进程的指针，则
>
> current->state = new_state;
>
> 操作系统同时有其他队列，当进程分配了CPU后，他开始执行并且最终完成，或者被中断，或等待特定时间发生。
>
> 假设进程向一个共享设备（比如磁盘）发送I/O请求，由于系统有其他进程，磁盘可能被其他设备占用，所以该进程需要等待。 （等待特定I/O设备的进程列表称为 **设备队列** 。每个设备有自己的设备队列

如下是就绪队列和各种设备队列图



<center><img src="https://miaochenlu.github.io/picture/1569658254174.png" alt="1569658254174" style="zoom:50%;" /></center>
#### 队列图

<center><img src="https://miaochenlu.github.io/picture/1569658436530.png" alt="1569658436530" style="zoom:50%;" /></center>
讨论进程调度的表示方法：队列图

一些符号的含义：

>  长方形代表队列。队列有两种：就绪队列和设备队列
>
> 圆形表示为队列服务的资源
>
> 箭头表示系统内进程的流向

状态会怎么切换呢？

* 进程发出I/O请求，被加入I/O队列
* 进程创建一个子进程，并等待其结束
* 进程可能会由于中断而强制释放CPU,并放回到就绪队列中

<br/>

### 2.2 调度程序

进程在生命周期中会在各种调度队列之间迁移。操作系统从这些队列中选择进程，这是由调度程序（调度器 scheduler)来执行的

* long-term scheduler
  * selects which processes should be brought into the ready queue.  
  * invoked very infrequently (seconds, minutes)
  * controls the *degree of* *multiprogramming*多道程序的“道” 
  * Most modern operating systems have no long-term scheduler (e.g. Windows, UNIX,Linux)
* short-term scheduler
  * selects which process should be executed next and allocates CPU
  * invoked very frequently(milliseconds)
* medium-term scheduler

<br/>

### 2.3 上下文切换

什么是上下文切换：

{:.info}

将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态。

> 发生上下文切换时，内核会将旧进程的状态保存在PCB中，然后装载经调度后要执行的并已经保存的新进程的上下文。
>
>  上下文切换是额外的时间开销



进程的上下文用PCB来表示。通常执行一个**状态保存**(state save)来保存CPU当前状态(不管是内核模式还是用户模式)，之后再执行一个**状态恢复**重新开始运行

<br/>

# 3 进程操作

## 3.1 进程创建

进程可以创建子进程，子进程又可以创建其他进程，形成进程树

<center><img src="https://miaochenlu.github.io/picture/image-20191212213321898.png" alt="image-20191212213321898" style="zoom:50%;" /></center>

进程的识别是通过唯一的进程识别符[process identifier pid]

### A. 父进程提供什么？

***父进程提供资源***一个进程创建子进程，子进程会需要一定的资源[CPU时间，内存，文件等]，这些可以从OS获得，或者可以从父进程获得。

***父进程传递初始化数据***

### B. 父子进程执行顺序

两种情况

* 父子进程并发执行
* 父进程等待，直到某个或者全部子进程执行完毕

### C. 父子进程地址空间

两种情况

* 子进程是父进程的复制
* 子进程加载另一个新程序



### D. 例子

`fork()`函数

一个进程可以通过系统调用 `fork` 来创建一个新的进程。`fork` 创建的新进程被称为**子进程**，子进程复制了了父进程的地址空间。`fork` 函数在父进程、子进程中都返回（一次调用两次返回）。对于父进程它返回子进程的 pid，对于子进程它返回 0。

<center><img src="https://miaochenlu.github.io/picture/image-20191212215625409.png" alt="image-20191212215625409" style="zoom:50%;" /></center>

考虑下面这段代码：

```cpp
int pid;
pid = fork();
if(pid > 0){
    printf("parent: child=%d\n", pid);
    pid = wait();
    printf("child %d is done\n", pid);
} else if(pid == 0){
    printf("child: exiting\n");
    exit();
} else {
    printf("fork error\n");
}
```

系统调用 `exit` 会导致调用它的进程停止运行，并且释放诸如内存和打开文件在内的资源。系统调用 `wait` 会返回一个当前进程已退出的子进程，如果没有子进程退出，`wait` 会等候直到有一个子进程退出。在上面的例子中，下面的两行输出

```
parent: child=1234
child: exiting
```

上面两行可能以任意顺序被打印，这种顺序由父进程或子进程谁先结束 `printf` 决定。当子进程退出时，父进程的 `wait`也就返回了，于是父进程打印：

```
parent: child 1234 is done
```

需要留意的是父子进程拥有不同的内存空间和寄存器，改变一个进程中的变量不会影响另一个进程。

<br/>

`exec()`函数

系统调用 `exec` 将从某个*文件*（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间。当`exec`执行成功后，它并不返回到原来的调用进程，而是从文件声明的入口开始，执行从文件中加载的指令。

```cpp
char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```

这段代码将调用程序替换为 `/bin/echo` 这个程序



## 3.2 进程终止

{:.success}

当进程执行完最后语句并通过系统调用`exit()`请求OS删除自身时，进程terminate。进程可以返回状态值到父进程[父进程`wait()`]。所有进程资源都会被释放。

父进程终止子进程的其他原因

* 子进程使用了超过父进程分配的资源
* 分配给子进程的任务不再需要
* 父进程正在退出，且OS不允许无父进程的子进程继续执行



{:.error}

zombie process: 子进程终止，但父进程还没调用wait()

OS释放子进程资源后，子进程在进程表中的条目依然存在，直至其父进程调用`wait()`



## 3.4 进程间通信 [Interprocess communication IPC]

### 3.4.1 协作

独立：一个进程不能影响其他进程或者被其他进程影响，那么该进程是独立的。

协作：如果系统中一个进程能影响或者被其他进程影响，那么该进程是协作的

<br/>

协作的优点

* Information sharing
* computation speed-up
* modularity
* convenience

<br/>

***协作需要进程间通信机制***

IPC provides a Mechanism for processes to **communicate** and to **synchronize** their actions **without sharing the same address space** .

<br/>

### 3.4.2 IPC分类

**通信类型：**

* **直接通信**

*  **间接通信**

**常用通信机制：**

* 信号(signal)  （中断？）

* 共享存储区(shared memory)

* 管道(pipe) （字节流过程）

* 消息(message)

* 套接字(socket)  （网络进程之间）



<center><img src="https://miaochenlu.github.io/picture/1569637406268.png" alt="1569637406268" style="zoom: 50%;" /></center>

### 3.4.2 two models of IPC

<center><img src="https://miaochenlu.github.io/picture/1569636805508.png" alt="1569636805508" style="zoom:50%;" /></center>
#### 3.4.2.1 shared memory

需要建立共享内存区域。

看一下Producer-Cunsumer问题

* unbounded buffer
* bounded buffer



```cpp
#define BUFFER_SIZE 10
typedef struct {
    ...
} item;

item buffer[BUFFER_SIZE];
int in = 0;		//in指向缓冲区下一个空位
int out = 0;	//out指向缓冲区下一个满位
//这种方法允许缓冲区的最大值为BUFFER_SIZE-1
/*
producer
*/
item nextProduced;

while(1) {
    //produce an item in nextProduced;
    while((in+1) % BUFFER_SIZE) == out)
        ;//do nothing
    buffer[in] = nextProduced;
    in = (in + 1) % BUFFER_SIZE;
}
/*
consumer
*/

item nextConsumed;
while(1) {
    while(in == out)
        ;//do nothing   相当于这个buffer是空的,所以do nothing
    nextConsumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
    //consume the item in nextConsumed
}
```

#### 3.4.2.2 Message Passing

If processes P and Q wish to communicate, they need to:

* Establish a communication link between them
* Exchange messages via send/receive



**A.命名**

> How are links established?
>
> Can a link be associated with more than two processes?
>
> How many links can there be between every pair of communicating processes?
>
> What is the capacity of a link?
>
> Is the size of a message that the link can accommodate fixed or variable?
>
> Is a link unidirectional or bi-directional?

***How are links established?***

> Implementation of communication link
>
> * Physical:
>
>   * Shared memory
>   * Hardware bus
>
>   * Network
>
> * Logical:
>   * Direct or indirect
>   * Synchronous or asynchronous
>   * Automatic or explicit buffering

***Can a link be associated with more than two processes?***

> * Direct communication（只有两个进程之间建立）
>   * Processes must name each other explicitly:
>     * **send** (*P, message*) – send a message to process P
>     * **receive**(*Q, message*) – receive a message from process Q
>   * Properties of communication link
>     * Links are established automatically
>     * A link is associated with exactly one pair of communicating processes
>     * Between each pair there exists exactly one link
>     * The link may be unidirectional, but is usually bi-directional
>
> * Indirect Communication（多个process共用）
>
>   * Messages are directed and received from mailboxes (also referred to as ports)
>
>     * Each mailbox has a unique id
>     * Processes can communicate only if they share a mailbox
>
>   * Properties of communication link
>
>     * Link established only if processes share a common mailbox
>     * A link may be associated with many processes
>     * Each pair of processes may share several communication links
>     * Link may be unidirectional or bi-directional
>
>   * Operations
>
>     * create a new mailbox (port）
>     * send and receive messages through mailbox
>     * destroy a mailbox
>
>   * Primitives are defined as:
>
>     * **send**(*A, message*) – send a message to mailbox A
>     *  **receive**(*A, message*) – receive a message from mailbox A
>
>   * Mailbox sharing
>
>     *P**1**, P**2**,* and ***P3*** share mailbox A
>
>     ***P1***, sends; ***P2*** and ***P3*** receive
>
>     Who gets the message?
>
>     Solutions
>
>     Allow a link to be associated with at most two processes
>
>     Allow only one process at a time to execute a receive operation
>
>     Allow the system to select arbitrarily the receiver.  Sender is notified who the receiver was.



**B. Synchronization**

> **Blocking**
>
> ​	considered synchronous
>
> * Blocking send: 发送者阻塞直到上一次发送的信息被接受
> * Blocking receive：接收者阻塞直到一个信息可以获得了
>
> **Non-blocking**
>
> ​	considered asynchronous
>
> 效率高，可靠性低
>
> * Non-blocking send: 主动持续发送信息
> * Non-blocking receive：主动不断去做接收的操作
>   * receive A valid message
>   * receive Null message

这四种方式可以组合，其中一种

send blocking + receive blocking ---> **rendezvous**



**C. Buffering**

> What is a buffer?
>
> ​	Queue of messages attached to the link.
>
> Implemented in 3 ways
>
> * Zero capacity – no messages are queued on a link.
>    Sender must wait for receiver (rendezvous)
> * Bounded capacity – finite length of *n* messages
>    Sender must wait if link full
> * Unbounded capacity – infinite length 
>    Sender never waits
>
> 

<br/>





<br/>

<br/>

references:

[1]https://github.com/ranxian/xv6-chinese/blob/master/content/chapter0.md

[2]operating system concepts

[3]http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf

