---
title: OS--CPU调度
key: page-OS5
tags: Operating-system
author: Chenlu Miao
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(34, 139, 87 , .4), rgba(139, 34, 139, .4))'
  background_image:
    src: https://miaochenlu.github.io/picture/ujiangyan.jpg


---

CPU调度

<!--more-->



# 1 基本概念

为什么要有CPU调度呢？

> 对于单处理器系统，每次只允许一个进程运行，其他进程需要等待，直到CPU空闲。
>
> 多道程序的目标是任何时候都有进程在运行，使得CPU使用率最大化。
>
> 可能某些进程在执行时，需要等待I/O请求，CPU就会空闲，OS就需要选择一个进程来拿走CPU的使用权

CPU调度的主要问题就是：

> 如何将有限的CPU资源分配给远远大于他的计算量

## 1.1 CPU-I/O区间周期

CPU成功调度依赖以下属性

> - 进程执行由CPU执行和I/O等待周期组成
> - 进程在这两个状态之间切换

进程执行从**CPU区间**(CPU burst)开始，之后是I/O burst,接着又是CPU burst,...最终，最后的CPU区间通过系统请求停止执行

<center><img src="https://miaochenlu.github.io/picture/image-20191218233312791.png" alt="image-20191218233312791" style="zoom:50%;" /></center>


下图使每种区间对应的区间时间和出现频率，这说明，CPU burst一般都是比较短的

<center><img src="https://miaochenlu.github.io/picture/image-20191218233339888.png" alt="image-20191218233339888" style="zoom:40%;" /></center>


## 1.2 CPU调度程序

当CPU空闲时，操作系统就会从就绪队列中选择一个进程来执行。

进程选择由短期调度程序[short-term scheduler]或CPU调度程序执行。

就绪队列中的记录是进程控制块[PCB], 根据调度算法排列，可以是先进先出队列，优先队列。。。

## 1.3 抢占调度[Preemptive]

CPU调度决策可以在如下4种环境

- 1 当一个进程从运行状态切换到等待状态[例如，I/O，或者调用wait等待一个子进程的终止]
- 2 当一个进程从运行状态切换到就绪状态(例如，当出现中断时)
- 3 当一个进程从等待状态切换到就绪状态[例如,I/O完成]
- 4 当一个进程终止时

第一和第四种情况，除了调度之外别无选择

第二和第三种情况，可以选择调度或者不调度

当调度只能发生在第1和第4两种情况，称调度方案时非抢占的[nonpreemptive], 或者协作的[cooperative]。否则，称调度方法是抢占的[preemptive]。

### 非抢占调度

> 调度程序一旦把处理器分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，其他进程才能被调度。如上1、4

### 抢占式调度

> 当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。

## 1.4 调度程序[dispatcher]

> - 切换上下文
> - 切换到用户模式
> - 跳转到用户程序的合适位置，以重新启动程序

调度延迟(dispatcher latency):调度程序停止一个进程到启动要给进程锁需要的时间

<center><img src="https://miaochenlu.github.io/picture/image-20191218234743745.png" alt="image-20191218234743745" style="zoom:40%;" /></center>
# 2 调度准则

面向用户的准则和评价

- <u>周转时间(turnaround time)</u>:进程从提交到完成的时间。包括：在CPU上执行，就绪队列和阻塞队列中等待时间

> 周转时间T=完成时间-提交时间
>
> 平均周转时间= $\sum$ 周转时间/进程数量
>
> 带权周转时间W=T(周转时间)/t(CPU执行时间)
>
> 平均带权中专时间=$\sum$W/进程数量

- <u>响应时间[reponse time]</u>：从进程提出请求到首次被响应(不是输出结果)的时间段
- <u>等待时间[waiting time]</u>：进程在就绪队列中等待的时间总和

- 截止时间：开始截止时间和完成截止时间，必须在什么时间完成...
- 公平性：不因作业或进程本身的特定而使上述指标过分恶化，比如长进程等待很长时间
- 优先级：可以使关键任务达到更好的指标



面向系统的调度性能准则

- 吞吐量:单位时间内完成的进程数量，跟进程本身特性和调度算法都有关系
- CPU 使用率：使得CPU尽可能忙碌
- 各种设备的均衡利用：如CPU繁忙的进程和I/O繁忙的进程搭配

最优准则

- Max CPU utilization
- Max throughput
- Min turnaround time
- Min waiting time
- Min response time

# 3 调度算法

调度算法如下：

- First-come, first-served
- shortest-job-first
- priority
- round robin
- multilevel queue
- multilevel feedback queue

## 3.1 先到先服务调度[FCFS]

是什么

> 先请求CPU的进程先分配到CPU[非抢占式]

特点

> 比较有利于长进程，不利于短进程
>
> 有利于CPU Bound的进程，不利于I/O Bound的进程

看一个例子

<center><img src="https://miaochenlu.github.io/picture/image-20191218235707714.png" alt="image-20191218235707714" style="zoom:50%;" /></center>
## 3.2 最短作业优先调度[SJF]

是什么

> 短进程优先
>
> 若剩余CPU burst相同 FCFS

SJF有抢占式的也有非抢占式的

SJF的变形

> 1. **shortest-remaining-time-first**. If a new process arrives with CPU burst length less than remaining time of current executing process, preempt.
>
> 2. Highest Response Ratio Next.
>
>    相应比R=(等待时间+要求执行时间)/要求执行时间
>
>    是FCFS和SJF的折中

一个非抢占式SJF的例子

<center><img src="https://miaochenlu.github.io/picture/image-20191219000036471.png" alt="image-20191219000036471" style="zoom:50%;" /></center>
抢占式的例子

<center><img src="https://miaochenlu.github.io/picture/image-20191219000103208.png" alt="image-20191219000103208" style="zoom:50%;" /></center>
SJF调度可以证明是optimal的，因为他的平均等待时间是最短的。

SJF的困难:没有办法知道一个进程还需要多少CPU burst

### Determining Length of Next CPU Burst

1.$t_n$=actual length of $n_{th}$ CPU burst

2.$\tau_{n+1}=$ predicted value for the next CPU burst

3.$\alpha,0\leq \alpha \leq 1$

4.Define 

$$\tau_{n+1}=\alpha t_n+(1-\alpha)\tau_n$$

$\alpha = 0\Rightarrow \tau_{n+1}=\tau_{n}$ recent history does not count

$\alpha=1\Rightarrow \tau_{n+1}=t_{n}$ only the actual last CPU burst counts

If we expand the formula, we get

$$\tau_{n+1}=\alpha t_n+(1-\alpha)\alpha t_{n-1}+\cdots+(1-\alpha)^j\alpha t_{n-j}+\cdots+(1-\alpha)^{n+1}\tau_0$$

因为$\alpha <=1$且$(1-\alpha)<1$，所以

根据前面一次的预测时间和真实时间来预测本次的时间

<center><img src="https://miaochenlu.github.io/picture/image-20191219085927748.png" alt="image-20191219085927748" style="zoom:40%;" /></center>
从上图可以发现，guess对真实的CPU burst有很好的跟踪性

## 3.3 Priority Scheduling

是什么

> 总是把CPU分配给就绪队列种具有最高优先权的进程
>
> 相同优先级FCFS

- 静态优先权: 静态优先权是在创建进程时确定的，在整个运行期间不再改变。依据有：进程类型、进程对资源的要求、用户要求的优先权。
- 动态优先权:动态优先权是基于某种原则，使进程的优先权随时间改变而改变。

假定：最小的整数=最高的优先级



一个non-preemptive的例子

<center><img src="https://miaochenlu.github.io/picture/image-20191219090848054.png" alt="image-20191219090848054" style="zoom:50%;" /></center>
一个preemptive的例子

<center><img src="https://miaochenlu.github.io/picture/image-20191219091002024.png" alt="image-20191219091002024" style="zoom:50%;" /></center>
#### problem

> Starvation: Low priority processes may never execute

#### Solution

> Aging: as time progresses increase the priority of the process--动态优先级

## 3.4 时间片轮转调度Round Robin[RR]

是什么

> 通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率

RR算法:

> 将系统中所有的就绪进程按照FCFS原则，排成一个队列
>
> 每次调度时将CPU分派给队首进程，让其**执行一个时间片** (*time slice/ time quantum*) 。
>
> 在一个时间片结束时，发生时钟中断。
>
> 调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。
>
> 进程可以未使用完一时间片，就出让CPU（如阻塞）

If there are *n* processes in the ready queue and the time quantum is *q*, then each process gets 1/*n* of the CPU time in chunks of at most *q* time units at once. No process waits more than (*n*-1)*q* time units.

- q large$\Rightarrow$ FIFO 时间片比较长，每一个进程都可以在时间片里面执行完，就和FIFO一样
- q small$\Rightarrow$ 大量上下文切换

那么时间片长度受什么影响呢？

> - 就绪进程的数目：数目越多，时间片越小
> - 系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间，平均周转时间和带权周转时间延长

example

<center><img src="https://miaochenlu.github.io/picture/image-20191219092609146.png" alt="image-20191219092609146" style="zoom:50%;" /></center>
## 3.5 多级队列调度[Multilevel queue scheduling]

是什么

> 根据进程的性质或者类型的不同，将就绪队列分成若干子队列
>
> 每个作业固定归入一个队列
>
> 各队列的处理不同：**不同队列可有不同的优先级、时间片长度、调度策略等。如：系统进程、用户交互进程、批处理进程等。**

比如：

foreground(interative) 前台(交互式)---RR

background(batch)后台(批处理)---FCFS

<br/>

多级队列算法调度须在队列间进行

**固定优先级调度**，即前台运行完后再运行后台。有可能产生饥饿

**给定时间片调度**，即每个队列得到一定的CPU时间，进程在给定时间内执行；如，**80%**的时间执行前台的**RR**调度，**20%**的时间执行后台的**FCFS**调度

<center><table>
  <tr>
    <td><div class="card">   
  <div class="card__image">     
  <img src="https://miaochenlu.github.io/picture/image-20191219094731453.png" alt="image-20191219094731453" style="zoom:50%;" />
  </div>   
  <div class="card__content">     
    <div class="card__header">       
      <h4>Separate queues for each priority</h4>     
    </div>      
  </div>
</div></td>
  <td><div class="card">   
  <div class="card__image">     
  <img src="https://miaochenlu.github.io/picture/image-20191219094812111.png" alt="image-20191219094812111" style="zoom:50%;" />
  </div>   
  <div class="card__content">     
    <div class="card__header">       
      <h4>Multilevel queue scheduling</h4>     
    </div>     
  </div>
 </div></td>
  </tr>
</table></center>





## 3.6 Multilevel Feedback Queue Scheduling

> 使用multilevel scheduling时，进程不会从一个队列转移到另一个队列。这样做的优点是调度开销低，缺点是不够灵活
>
> multilevel feedback queue scheduling允许进程在队列之间移动

<center><img src="https://miaochenlu.github.io/picture/image-20191219100140246.png" alt="image-20191219100140246" style="zoom:50%;" /></center>
<br/>

* 设置<u>多个就绪队列</u>，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长，如逐级加倍

* 新进程进入内存后，先投入队列0的末尾，按FCFS算法调度，获得一个time quantum；<u>若按队列0一个时间片未能执行完，则降低投入到队列1的末尾，同样按FCFS算法调度</u>, 获得一个quantum；如此下去，降低到最后的队列，则按"时间片轮转"算法调度直到完成。

* 仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢占执行新进程，并把被抢占的进程投入原队列的末尾。

<br/>

**多级反馈队列**算法是时间片轮转算法和优先级算法的综合和发展  

`优点`{:.优点}

* 为提高系统吞吐量和缩短平均周转时间而照顾短进程

* 为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程

* 不必估计进程的执行时间，动态调节