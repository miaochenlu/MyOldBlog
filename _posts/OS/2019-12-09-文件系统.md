---
title: OS--文件系统
key: page-OS11
tags: Operating-system
author: Chenlu Miao
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(34, 139, 87 , .4), rgba(139, 34, 139, .4))'
  background_image:
    src: https://miaochenlu.github.io/picture/IMG_175820190715-004751.png

---



<!--more-->

# 1. File-system structure

文件系统是一个层次结构

<img src="https://miaochenlu.github.io/picture/image-20191214135608936.png" alt="image-20191214135608936" style="zoom:50%;" />



* I/O control

  * I/O control由<u>设备驱动程序</u>和<u>中断处理程序</u>组成。

  * 实现<u>内存与磁盘</u>之间的信息传输

> 设备驱动程序像是一个翻译器。
>
> 输入是高层命令：如`retrieve block 123`
>
> 输出是底层的、硬件特定的命令组成，用于控制硬件控制器

* Basic file system
  * 向合适的设备驱动程序发送一般命令就可以对磁盘上的物理块进行读写。每个块由其数值磁盘地址来标识[如驱动器1, cylinder 73, track 3, sector 10]
* file-organization module
  * <u>逻辑块物理块转换</u>，<u>空闲空间管理器</u>
  * 知道文件及其逻辑块和物理块。将逻辑块地址转换成基本文件系统所用的物理块地址
* logical file system
  * <u>文件控制块</u>[拥有者、权限、文件内容的位置]
  * 管理元数据[包括文件系统的所有数据结构，不包括文件内容]

# 2. File system implementation

## 2.1 Overview

在磁盘上，文件系统可能包括如下信息：

* 如何启动所存储的操作系统

* 总的块数

* 空闲块的数目和位置

* 目录结构以及各个具体文件等

磁盘结构包括

* **引导控制块**（boot control block）：通常为分区的第一块。如果该分区没有OS，则为空。（其他名称：引导块（Linux）、分区引导扇区（WindowsNT））

* **分区控制块**（volume control block）：包括分区详细信息，如分区的块数、块的大小、空闲块的数量和指针、空闲FCB的数量和指针等（亦称为超级块（Linux）、主控文件表（WindowsNT））

* **目录结构**：用来组织文件，UFS中它包含文件名和相关的索引节点（inode）。NTFS中它存储在主控文件表。

* **文件控制块（FCB）**：包括很多文件信息，如文件许可、拥有者、大小和数据块的位置等。UFS称为索引节点（inode）。NTFS把它存储在主控文件表，每个文件占一行。

<center><img src="https://miaochenlu.github.io/picture/image-20191214143617814.png" alt="image-20191214143617814" style="zoom:35%;" /></center>




> 为了创建一个新文件
>
> * 应用程序调用逻辑文件系统。
> * 逻辑文件系统知道目录结构形式。为了创建一个新文件，它将分配一个新的FCB（如果文件系统在创建时就已经创建了所有的FCB，就分配一个空闲的FCB）。然后系统把相应的目录信息读入内存，用新的文件名更新该目录和FCB，并将结果写回磁盘。

<center><img src="https://miaochenlu.github.io/picture/image-20191214144000484.png" alt="image-20191214144000484" style="zoom:50%;" /></center>
(a) 打开文件。一旦文件被创建，它就能用于IO。首先打开文件。

* 调用`open()`将文件名传给文件系统。
* `open()`会首先搜索系统范围内的打开文件表以确定某文件是否已被其他进程所使用。
  * 如果是，就在单个进程的打开文件表中创建一项，并指向现有系统范围的打开文件表。该算法能节省大量开销。
  * 如果否，根据给定的文件名搜索目录结构，部分目录结构通常缓存在内存中以加快目录操作。
* 一旦找到文件，把FCB复制到系统范围的打开文件表，该表不但存储FCB，而且还跟踪打开该文件的进程数量。
* 接着，在单个进程的打开文件表中会增加一个条目，并通过指针将系统范围内的打开文件表的条目相连。
* `open()`函数返回一个指向单个进程的打开文件表中合适条目的指针，所有后续操作都通过这个指针，unix里称为文件描述符，windows里称为文件句柄。

(b) 读文件。

* 通过`read()`调用打开后返回的指针，
* 首先索引单个进程的打开文件表
* 再连接到系统范围的打开连接表
* 最后读磁盘上的数据块。内存中也缓冲了一些相应的数据块。

<br/>

## 2.2 分区与安装

<a href="http://cn.linux.vbird.org/linux_basic/0130designlinux_2.php">磁盘分区介绍</a>

先略过吧，觉得自己鸟哥这篇写的挺清楚的

## 2.3 Virtual file system

<div class="item">   
  <div class="item__image"> 
    <img class="image image--lg" src="https://miaochenlu.github.io/picture/image-20191214145057623.png" alt="image-20191214145057623" style="zoom:50%;" />
  </div>   
  <div class="item__content">     
  <div class="item__header">       
    <h4>NFS中的挂载</h4>     
  </div>     
  <div class="item__description">     
    <p>1. 第一层是文件系统接口，包括open，read，write，close和文件描述符</p>
    <p>2. 第二层是VFS接口，他有两个目的（1）将文件系统的通用操作和具体实现分开，多个vfs接口的实现可以共存于同一台电脑，访问本地多个类型的文件系统（2）vfs提供了网络上唯一标识一个文件的机制vnode。因此vfs接口能够区分本地文件和远程文件，根据文件系统类型进一步区分不同的本地文件</p>
		<p>3. 第三层实现具体文件系统类型和远程文件系统协议。Linux vfs定义了4种主要的对象类型：索引节点对象（表示一个单独的文件），文件对象（表示一个打开的文件），超级块对象（表示整个文件系统），目录条目对象（表示一个单独的目录条目）</p>
  </div>   
 </div> 
</div>



# 3. Directory implementation

## 3.1 Linear list

* 采用线性搜索来查找特定条目（缺点）

* 许多操作系统采用软件缓存来存储最近访问过的目录信息

<center><img src="https://miaochenlu.github.io/picture/image-20191214145647389.png" alt="image-20191214145647389" style="zoom:40%;" /></center>
## 3.2 Hash Table

除了使用线性列表存储目录条目外，还使用了hash数据结构。Hash表根据文件名得到一个值，并返回一个指向线性列表中元素的指针。

链式hash表，每个hash条目指向一个链表，先hash，再链表搜索。

<br/>

# 4. 分配方法

## 4.1 连续分配

<div class="item">   
  <div class="item__image"> 
    <img class="image image--lg" src="https://miaochenlu.github.io/picture/image-20191208110156876.png" alt="image-20191208110156876" style="zoom:45%;" />
  </div>   
  <div class="item__content">     
  <div class="item__header">       
    <h4>Continous Allocation</h4>     
  </div>     
  <div class="item__description">     
    <p>每个文件在磁盘上占有一组连续的块。</p>
    <p>文件的连续分配可以用第一块的磁盘地址和连续块的数量来定义。如directory中所示，一个文件需要有[start, length]这样一对信息</p>
  </div>   
 </div> 
</div>

<center><img src="https://miaochenlu.github.io/picture/image-20191214175511225.png" alt="image-20191214175511225" style="zoom:50%;" /></center>
`优点`{:.success}

* 性能良好。假设只有一个作业访问磁盘，在访问块b后访问块b+1通常不需要移动磁头，需要时一般也只需要移动一个磁道。寻道数少
* 支持顺序访问和直接访问。要顺序访问，文件系统会记住上次访问过的块

`缺点`{:.error}

* 难以为新文件找到空间
* 外部碎片
* 难以确定一个文件需要多少空间
  * 分配太小-->难以扩展

<center><img src="https://miaochenlu.github.io/picture/image-20191214150242686.png" alt="image-20191214150242686" style="zoom:50%;" /></center>
<br/>

### Extend-Based Systems

许多新的文件系统采用一种优化的连续分配方法

该方法开始分配一块连续空间，当空间不够时，另一块被称为扩展的连续空间会添加到原来的分配中。

文件块的位置就成为开始地址、块数、加上一个指向下一扩展的指针。

<center><img src="https://miaochenlu.github.io/picture/image-20191214150420089.png" alt="image-20191214150420089" style="zoom:50%;" /></center>
## 4.2 链接分配[linked allocation]



<div class="item">   
  <div class="item__image"> 
    <img class="image image--lg" src="https://miaochenlu.github.io/picture/image-20191207100135972.png" alt="image-20191207100135972" style="zoom:45%;" />
  </div>   
  <div class="item__content">     
  <div class="item__header">       
    <h4>linked Allocation</h4>     
  </div>     
  <div class="item__description">     
    <p>每个文件是磁盘块的链表。目录包括文件第一块的指针和最后一块的指针</p>
    <p>如图：一个有5块的文件，从块9开始，然后是块16， 1， 10， 最后是25。</p>
  </div>   
 </div> 
</div>

<div class="card">   
  <div class="card__content"> 
    <div class="card__image">     
      <img class="image" src="https://miaochenlu.github.io/picture/image-20191214150737997.png" alt="image-20191214150737997" style="zoom:67%;" /></div>
    <div class="card__header">       
      <h4>disk block</h4>     
    </div>     
  </div>
</div>



* 要创建新文件，可以简单地在目录中增加一个entry。

  每个directory entry都有一个指向文件首块的指针，这个指针初始化为nil，表示空文件

* 要写文件，空闲空间管理系统会找到一个空闲块，然后这个空闲块被写入并且链接到文件到尾部。
* 要读文件，可以通过块到块的指针

<center><img src="https://miaochenlu.github.io/picture/image-20191214175629361.png" alt="image-20191214175629361" style="zoom:50%;" /></center>
`优点`{:.success}

* 没有外部碎片
* 创建文件时，不需要说明文件大小，只要有空闲块，文件就可以增大

`缺点`{:.error}

* 只能顺序访问
* 每个块中的指向下一个块的指针都需要占用空间
* 可靠性问题。因为指针分布在整个磁盘上，如果指针丢失或损坏，会导致链接空闲空间列表或者另一个文件

<center><img src="https://miaochenlu.github.io/picture/image-20191208120328197.png" alt="image-20191208120328197" style="zoom:40%;" /></center>
<br/>

## 4.3 索引分配[indexed allocation]

连续分配和链接分配的问题

{:.error}

链接分配可以解决连续分配的***<u>外部碎片</u>***和***<u>大小声明</u>***问题。但是如果不用FAT，那么链接分配是不能有效支持***<u>直接访问</u>***的，因为块指针和块一起分布在整个磁盘，必须按顺序读取。

索引分配通过把所有文件块的指针放在一个***<u>索引块</u>***，解决了这个问题

* 索引块是一个磁盘块地址的数组，<u>索引块的第i个entry指向文件的第i个块</u>

  <center><img src="https://miaochenlu.github.io/picture/image-20191208122209693.png" alt="image-20191208122209693" style="zoom: 3%;" /></center>

* directory entry包括索引块的地址

<br/>

> 创建文件时，索引块的所有指针都为nil。
>
> 当首次写入第i块，先从空闲空间管理器中得到一块，再将其地址写到索引块的第i个entry
>
> 如果要读第i块，通过索引块的第i个entry

<center><img src="https://miaochenlu.github.io/picture/image-20191207102636309.png" alt="image-20191207102636309" style="zoom:50%;" /></center>
<center><img src="https://miaochenlu.github.io/picture/image-20191214180614018.png" alt="image-20191214180614018" style="zoom:50%;" /></center>


### 如何组织索引块

* Linked scheme

  {:.info}

  为了处理大文件，可以将多个***<u>索引块链接</u>***起来

  an index block might contain 

  * a small header giving the name of the file 
* a set of the first 100 disk-block addresses.
  
  * The next address (the last word in the index block) is null (for a small file) or is a pointer to another index block (for a large file).


<center><img src="https://miaochenlu.github.io/picture/image-20191214180728768.png" alt="image-20191214180728768" style="zoom:50%;" /></center>
* Multilevel index

  {:.info}

  第一层索引块指向一组第二层的索引块，第二层的索引块再指向文件块。

  为了访问一个块，操作系统通过第一层索引查找到第二层索引，再用第二层索引查找所需的数据块。

  <center><img src="https://miaochenlu.github.io/picture/image-20191208122123461.png" alt="image-20191208122123461" style="zoom:40%;" /></center>
<center><img src="https://miaochenlu.github.io/picture/image-20191214180807368.png" alt="image-20191214180807368" style="zoom:50%;" /></center>
  
* combined scheme[**UNIX UFS**]

  将索引块的头15个指针存在文件的inode中。

  1. 12个指向直接块，直接访问数据块

  2. 1个一级间接块
  3. 1个二级间接块
  4. 1个三级间接块

<center><img src="https://miaochenlu.github.io/picture/image-20191208122503426.png" alt="image-20191208122503426" style="zoom:50%;" /></center>




> 一个文件系统中有一个20MB大文件和一个20KB小文件,当分别采用连续、链接分配、二级索引、Linux分配方案时，每块大小为4096B，每块地址用4B表示，问:
>
> （1）各文件系统管理的最大的文件是多少? 
>
> （2）每种方案对大、小两文件各需要多少专用块来记录文件的物理地址(说明各块的用途) ?
>
> （3）如需要读大文件前面第5.5KB的信息和后面第（16M＋5.5KB）的信息，则每个方案各需要多少次磁盘I/O操作? 

1.

* 连续分配：理论上是不受限制，可大到整个磁盘文件区。

- 隐式链接：由于块的地址为4字节，所以能表示的最多块数为 232=4G，而每个盘块中存放文件大小为4092字节。链接分配可管理的最大文件为：4G×4092B=16368GB
- 链接索引：由于块的地址为4字节，所以最多的链接索引块数为 232=4G，而每个索引块有1023个文件块地址的指针，盘块大小为4KB。假设最多有n个索引块，则1023×n+n=232，算出n=222，链接索引分配可管理的最大文件为：4M*1023*4KB=16368GB
- 二级索引：由于盘块大小为4KB，每个地址用4B表示，一个盘块可存1K个索引表目。
  二级索引可管理的最大文件容量为4KB×1K×1K＝4GB。
- LINUX混合分配：LINUX的直接地址指针有12个，还有一个一级索引，一个二级索引，一个三级索引。因此可管理的最大文件为48KB＋4MB+4GB＋4TB。

2. 

- 连续分配：对大小两个文件都只需在文件控制块FCB中设二项，一是首块物理块块号，另一是文件总块数，不需专用块来记录文件的物理地址。
- 隐式链接：对大小两个文件都只需在文件控制块FCB中设二项，一是首块物理块块号，另一是末块物理块块号；同时在文件的每个物理块中设置存放下一个块号的指针。
- 一级索引：对20KB小文件只有5个物理块大小，所以只需一块专用物理块来作索引块，用来保存文件的各个物理块地址。对于20MB大文件共有5K个物理块，由于链接索引的每个索引块只能保存（1K－1）个文件物理块地址（另有一个表目存放下一个索引块指针），所以它需要6块专用物理块来作链接索引块，用于保存文件各个的物理地址。
- 二级索引：对大小文件都固定要用二级索引，对20KB小文件，用一个物理块作第一级索引，用另一块作二级索引，共用二块专用物理块作索引块，对于20MB大文件，用一块作第一级索引，用5块作第二级索引，共用六块专用物理块作索引块。
- LINUX的混合分配：对20KB小文件只需在文件控制块FCB的i_addr[15]中使用前5个表目存放文件的物理块号，不需专用物理块。对20MB大文件，FCB的i_addr[15]中使用前12个表目存放大文件前12块物理块块号（48K），用一级索引块一块保存大文件接着的1K块块号（4M），剩下还有不到16M，还要用二级索引存大文件以后的块号，二级索引使用第一级索引1块，第二级索引4块（因为4KB×1K×4=16 M）。总共也需要6块专用物理块来存放文件物理地址。

3. 

- 连续分配：为读大文件前面和后面信息都需先计算信息在文件中相对块数，前面信息相对逻辑块号为5.5K／4K=1（从0开始编号），后面信息相对逻辑块号为（16M＋5.5K）/4K=4097。再计算物理块号＝文件首块号＋相对逻辑块号，最后化一次盘I/O操作读出该块信息。
- 链接分配：为读大文件前面5.5KB的信息，只需先读一次文件头块得到信息所在块的块号，再读一次第1号逻辑块得到所需信息，共2次。而读大文件16MB＋5.5KB处的信息，逻辑块号为（16M＋5.5K）/4092=4107，要先把该信息所在块前面块顺序读出，共化费4107次盘I／O操作，才能得到信息所在块的块号，最后化一次I/O操作读出该块信息。所以总共需要4108次盘I／O才能读取（16MB+5.5KB）处信息。
- 链接索引：为读大文件前面5.5KB处的信息，只需先读一次第一个索引块得到信息所在块的块号，再读一次第1号逻辑块得到所需信息，共化费2次盘I／O操作。为读大文件后面16MB+5.5KB处的信息，(16MB+5.5KB)/(4KB×1023)=4,需要先化5次盘I／O操作依次读出各索引块，才能得到信息所在块的块号，再化一次盘I/O操作读出该块信息。共化费6次盘I／O操作。
- 二级索引：为读大文件前面和后面信息的操作相同，首先进行一次盘I／O读第一级索引块，然后根据它的相对逻辑块号计算应该读第二级索引的那块，第一级索引块表目号=相对逻辑块号／1K，对文件前面信息1／1K＝0，对文件后面信息4097／1K＝4，第二次根据第一级索引块的相应表目内容又化一次盘I／O读第二级索引块，得到信息所在块块号，再化一次盘I／O读出信息所在盘块，这样读取大文件前面或后面处信息都只需要3次盘I／O操作。
- LINUX混合分配：为读大文件前面5.5KB处信息，先根据它的相对逻辑块号，在内存文件控制块FCB的i_addr第二个表目中读取信息所在块块号，而只化费一次盘I／O操作即可读出该块信息。为读大文件后在（16MB＋5.5KB）信息，先根据它的相对逻辑块号判断要读的信息是在二级索引管理范围内，先根据i_addr内容化一次盘I／O操作读出第一级索引块，再计算信息所在块的索引块号在第一级索引块的表目号为（4097-12-1024）／1024＝2，根据第一级索引块第3个表目内容再化费一次盘I／O操作，读出第二级索引块，就可以得到信息所在块块号，最后化一次盘I／O读出信息所在盘块，这样总共需要3次盘I／O操作才能读出文件后面的信息。

<center><img src="https://miaochenlu.github.io/picture/image-20191208123006518.png" alt="image-20191208123006518" style="zoom:40%;" /></center>




# 5. Free-space management

## 5.1 bit map[bit vector]

<center><img src="https://miaochenlu.github.io/picture/image-20191214153823825.png" alt="image-20191214153823825" style="zoom:40%;" /></center>
Free Block number calculation:

> (number of bits per word) *(number of 0-value words) +offset of first 1 bit

## 5.2 linked list

<center><img src="https://miaochenlu.github.io/picture/image-20191214154243773.png" alt="image-20191214154243773" style="zoom:50%;" /></center>
# 7. Recovery

* <u>Consistency checking</u> : compares data in directory structure with data blocks on disk, and tries to fix inconsistencies

* Use system programs to back up data from disk to another storage device [magnetic tape, other magnetic disk, optical]

* Recover lost file or disk by restoring data from backup

## 7.1 Log structured file systems

wow, log! 

seems like what I'm doing on STM | HTM



# 8. NFS

## 8.1 Overview

NFS是通过局域网[广域网]访问远程文件的软件系统的实现和规范



NFS将一组互联工作站作为具有独立文件系统的机器组合，目的是允许透明的共享这些文件系统。

透明：就好像操作本地一样

为了使一台特定机器M1透明地访问远程目录，M1的一个客户端必须先执行安装`mount`操作，将远程目录安装到本地文件系统的目录上。安装完成后，远程目录就与本地文件系统有机集成起来，取代了原来本地目录下的内容。本地目录就称为新安装目录的根的名称

<div class="item">   
  <div class="item__image"> 
    <img class="image image--lg" src="https://miaochenlu.github.io/picture/image-20191209142448392.png" alt="image-20191209142448392" style="zoom:40%;" /> 
  </div>   
  <div class="item__content">     
  <div class="item__header">       
    <h4>三个独立的文件系统</h4>     
  </div>     
  <div class="item__description">     
    <p>图中有三台机器的U, S1, S2的三个独立文件系统，三角形表示所感兴趣的目录子树。这时每台机器只能访问本地文件系统。</p>  
  </div>   
  </div> 
</div>

<div class="item">   
  <div class="item__image"> 
    <img class="image image--lg" src="https://miaochenlu.github.io/picture/image-20191209142525254.png" alt="image-20191209142525254" style="zoom:50%;" />
  </div>   
  <div class="item__content">     
  <div class="item__header">       
    <h4>NFS中的挂载</h4>     
  </div>     
  <div class="item__description">     
    <p>图(a)说明了将S1:/usr/shared安装到U:/usr/local的情况。安装完成后可以用/usr/local/dir1访问目录dir1内的任何文件</p>
    <p>
      图(b)说明了串联安装,安装S2:/usr/dir2到U:/usr/local/dir1的结果
    </p>
  </div>   
  </div> 
</div>

{:.success}

NFS是独立于机器、操作系统和网络结构的。这种独立性是因为在两种独立实现接口之间采用基于外部数据表示[XDR]的RPC而带来的。

## 8.2 mount protocol

{:.info}

mount protocol在客户机和服务器之间建立初始逻辑连接

安装操作

* Establishes initial ***<u>logical connection</u>*** between server and client

* Mount operation includes name of ***<u>remote directory</u>*** to be mounted and name of ***<u>server machine</u>*** storing it
  * Mount request is mapped to corresponding RPC and forwarded to mount server running on server machine 
  * Export list – specifies local file systems that server exports for mounting, along with names of machines that are permitted to mount them 

* Following a mount request that conforms to its export list, the server returns a file handle—a key for further accesses

* File handle – a file-system identifier, and an inode number to identify the mounted directory within the exported file system

* The mount operation changes only the user’s view and does not affect the server side 

## 8.3 NFS protocol

Provides a set of remote procedure calls for remote file operations. The procedures support the following operations:

* searching for a file within a directory 

* reading a set of directory entries 

* manipulating links and directories 

* accessing file attributes

* reading and writing files

<center><img src="https://miaochenlu.github.io/picture/image-20191214181628603.png" alt="image-20191214181628603" style="zoom:50%;" /></center>
references

[1]http://cn.linux.vbird.org/linux_basic/0130designlinux_2.php