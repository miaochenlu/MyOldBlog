---

layout: post

title: "Computer Architecture"

date: 2019-09-08 12:21:05 +0800

categories: jekyll update

---



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [ ['$','$'], ['\(', '\)'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true,
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [ ['$','$'], ['\(', '\)'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true,
}
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

<h1>目录</h1>

<a href="#ISA">附录A 指令集基本原理 </a>

<a href="#pipline">附录C流水线</a>

<br/>
<br/>

# <a name="ISA">附录A 指令集基本原理 </a>

## 1 What is ISA?

ISA: Instruction Set Architecture

<img src="http://miaochenlu.github.io/picture/image-20190930101228492.png" alt="image-20190930101228492" style="zoom: 33%;" />



## 2 What types of ISA?

### 2.1 Basis

* type of internal storage

> stack
>
> accumulator
>
> Register

<br/>

先来解释一下implicit operand和explicit operand

* explicit operand

明确到哪个地方去取的操作数，比如到某一个由指令确定的寄存器，或者内存中一个由指令确定的地址

* implicit operand

不明确的取值位置，但是系统默认了。比如stack architecture就是默认到stack头部去取，accumulator architecture就是默认到accumulator中去取。

<br/>

#### 2.1.1 Stack Architecture

***<u>operand</u>***:

>  2 <u>***implicit***</u> operands on the top of the stack(***TOS***)

用图来看一下以下操作的过程

```
C = A + B (memory locations)
Push A
Push B
Add 
Pop C
```

<figure>
  <img src="http://miaochenlu.github.io/picture/image-20190930102555608.png" alt="image-20190930102555608" style="zoom:40%;" title="original"/>
  <img src="http://miaochenlu.github.io/picture/image-20190930102855084.png" alt="image-20190930102855084" style="zoom:50%;" title="push A"/>
  <img src="http://miaochenlu.github.io/picture/image-20190930103000391.png" alt="image-20190930103000391" style="zoom:50%;" title="push B"/>
  <img src="http://miaochenlu.github.io/picture/image-20190930103037853.png" alt="image-20190930103037853" style="zoom:50%;" title="Add"/>
  <img src="http://miaochenlu.github.io/picture/image-20190930103101742.png" alt="image-20190930103101742" style="zoom:50%;" title="pop C" />
</figure>

 

#### 2.1.2 Accumulator Architecture

<u>***operand***</u>

> one implicit operand: accumulator
>
> one explicit operand: mem location

看一下以下操作的过程

```
C = A + B
Load A
Add B
Store C

accumulator is both 
an implicit input operand 
and a result
```

<figure>
  <img src="http://miaochenlu.github.io/picture/image-20190930115553486.png" alt="image-20190930115553486" style="zoom:40%;" title="original"/>
  <img src="http://miaochenlu.github.io/picture/image-20190930115635931.png" alt="image-20190930115635931" style="zoom:50%;" title="load A"/>
  <img src="http://miaochenlu.github.io/picture/image-20190930115734010.png" alt="image-20190930115734010" style="zoom:50%;" title="add B"/>
  <img src="http://miaochenlu.github.io/picture/image-20190930115804883.png" alt="image-20190930115804883" style="zoom:50%;" title="store C"/>
</figure>

  

<table>
  <tr>
    <td>
      <img src="http://miaochenlu.github.io/picture/image-20190930115553486.png" alt="image-20190930115553486" title="original"/>
    </td>
    <td>
  <img src="http://miaochenlu.github.io/picture/image-20190930115635931.png" alt="image-20190930115635931" title="load A"/>
    </td>
  	<td>
  <img src="http://miaochenlu.github.io/picture/image-20190930115734010.png" alt="image-20190930115734010" title="add B"/>
    </td>
    <td>
  <img src="http://miaochenlu.github.io/picture/image-20190930115804883.png" alt="image-20190930115804883" title="store C"/>
    </td>
  </tr>
</table>







<h1><a name="pipline">附录C流水线</a></h1>
## 1 什么是流水线
流水线是一种将多条指令 ***重叠执行*** 的实现技术  

一条执行包含多种操作，流水线充分利用了这些 ***操作之间的并行性***
<br/>

为了能更形象地理解这个问题，不妨用汽车装配线来做类比    

> 汽车装配线的每一环节负责一项任务，所有环节是并行的（也就是不同的汽车同时在不同的环节上）  
> 
> 在流水线中，指令就像是一辆待装配的汽车，不同环节完成指令的一部分,这些环节的每一步称为 ***流水级或者流水段***。流水级前后相连形成流水线  
> 
> 汽车装配线的 ***吞吐量*** 定义为单位时间生产的汽车数量，由完整汽车退出装配线的频率决定
>   
> 流水线的吞吐量由指令退出流水线的频率决定。一条指令在流水线中下移一步需要的时间为 ***处理器周期*** 。因为各个环节同时执行，所以处理器周期由最缓慢的流水线级确定。

可以想见，要使流水线性能高，平衡各流水线级很重要  

因为处理器周期由最缓慢的流水线级确定，我们想要使最缓慢环节的加快，就要平衡各流水线级。  

如果各级达到完美平衡，那么每条指令在流水线处理器中的时间为  

$$\frac{非流水线机器上每条指令的时间}{流水级的数目}$$  

在这些条件下，流水线加速比=流水级的数目

<br/>

# 2 RISC指令集

我们以RISC指令集为例来了解一下流水线实现。一下，我们会介绍RISC指令集以及没有流水线的实现方式。

RISC指令集子集中每条指令都可以在5个时钟周期以内实现。以MIPS指令集为例介绍这5个时钟周期

* ***指令提取周期(IF(Instruction Fetch))***  

* ***指令译码/寄存器提取周期(ID)***  

* ***执行/有效地址周期(EX)***  

* ***存储器访问(MEM)***

* ***写回周期(WB)***


<br/>

# 3 RISC处理器经典五级流水线

<img src="http://miaochenlu.github.io/picture/ca20190908-1.png" width="600">

<img src="http://miaochenlu.github.io/picture/ca20190908-2.png" width="600">

# 4 流水化的主要阻碍-流水线冒险
冒险降低来了流水化所能带来的理想加速比  
冒险共有一下三类  

1. 结构冒险  
            在重叠执行模式下，硬件无法同时支持指令的所有可能组合，就会出现资源冲突
2. 数据冒险  
            指令之间存在先后顺序，一条指令取决于先前指令的结果
3. 控制冒险  
            分支指令以及其他改变程序计数器的指令会导致控制冒险
            

为了避免冒险，要求流水线中的一些指令延迟时，其他指令能够继续执行  

<br/>

## 4.1 带有停顿的流水线性能  
$$
\begin{aligned}
流水化加速比&=\frac{非流水化指令平均执行时间}{流水化指令平均执行时间}\\
&=\frac{非流水化CPI\times 非流水化时钟周期}{流水化CPU\times 流水化时钟周期}\\
&=\frac{非流水化CPI}{流水化CPI}\times \frac{非流水化时钟周期}{流水化时钟周期}
\end{aligned}
$$

<br/>

流水化处理器的理想CPI几乎总是等于1，算上停顿
$$\begin{aligned}
流水化CPI&=理想CPI+每条指令的流水线停顿时钟周期\\
&=1+每条指令的流水线停顿时间周期
\end{aligned}$$



[jekyll-docs]: https://jekyllrb.com/docs/home

[jekyll-gh]: https://github.com/jekyll/jekyll

[jekyll-talk]: https://talk.jekyllrb.com/